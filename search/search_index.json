{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Headers for Humans \ud83d\udc4b Object oriented headers, parser and builder. HTTP/1.1 Style. kiss-headers stand for, headers, keep it sweet and simple. Principle KISS . It\u2019s a basic library, small and concise to help you get things done regarding headers in a better way. \ud83d\udd2a Features kiss-headers is a basic library that allows you to handle headers as objects. A backwards-compatible syntax using bracket style. Capability to alter headers using simple, human-readable operator notation + and - . Flexibility if headers are from an email or HTTP, use as you need with one library. Ability to parse any object and extract recognized headers from it, it also supports UTF-8 encoded headers. Fully type-annotated. Provide great auto-completion in Python interpreter or any capable IDE. No dependencies. And never will be. 90% test coverage. Plus all the features that you would expect from handling headers\u2026 Properties syntax for headers and attribute in header. Supports headers and attributes OneToOne, OneToMany and ManySquashedIntoOne. Capable of parsing bytes , fp , str , dict , email.Message , requests.Response , httpx._models.Response and urllib3.HTTPResponse . Automatically unquote and unfold the value of an attribute when retrieving it. Keep headers and attributes ordering. Case insensitive with header name and attribute key. Character - equal _ in addition of above feature. Any syntax you like, we like. Note Even if this library offers wide support to handle headers as they were objects you should know that headers are not obligated to follow any syntax. But we are pretty confident that this library cover at least 99 % of the use cases you could encounter. Feel free to address any issue you may encounter. \u2728 Installation Whatever you like, use pipenv or pip , it simply works. Requires Python 3.6+ installed. pip install kiss-headers \ud83d\udcdd License Copyright \u00a9 2020 Ahmed TAHRI @Ousret . This project is MIT licensed.","title":"Introduction"},{"location":"#features","text":"kiss-headers is a basic library that allows you to handle headers as objects. A backwards-compatible syntax using bracket style. Capability to alter headers using simple, human-readable operator notation + and - . Flexibility if headers are from an email or HTTP, use as you need with one library. Ability to parse any object and extract recognized headers from it, it also supports UTF-8 encoded headers. Fully type-annotated. Provide great auto-completion in Python interpreter or any capable IDE. No dependencies. And never will be. 90% test coverage. Plus all the features that you would expect from handling headers\u2026 Properties syntax for headers and attribute in header. Supports headers and attributes OneToOne, OneToMany and ManySquashedIntoOne. Capable of parsing bytes , fp , str , dict , email.Message , requests.Response , httpx._models.Response and urllib3.HTTPResponse . Automatically unquote and unfold the value of an attribute when retrieving it. Keep headers and attributes ordering. Case insensitive with header name and attribute key. Character - equal _ in addition of above feature. Any syntax you like, we like. Note Even if this library offers wide support to handle headers as they were objects you should know that headers are not obligated to follow any syntax. But we are pretty confident that this library cover at least 99 % of the use cases you could encounter. Feel free to address any issue you may encounter.","title":"\ud83d\udd2a Features"},{"location":"#installation","text":"Whatever you like, use pipenv or pip , it simply works. Requires Python 3.6+ installed. pip install kiss-headers","title":"\u2728 Installation"},{"location":"#license","text":"Copyright \u00a9 2020 Ahmed TAHRI @Ousret . This project is MIT licensed.","title":"\ud83d\udcdd License"},{"location":"advanced-header/","text":"Header Class This class is used to represent a single header as an object. An Header can be casted to str , bytes and dict . Given this : from kiss_headers import Header header = Header ( \"Content-Type\" , \"text/html; charset=UTF-8\" ) str ( header ) # output: 'text/html; charset=UTF-8' repr ( header ) # output: 'Content-Type: text/html; charset=UTF-8' bytes ( header ) # output: b'Content-Type: text/html; charset=UTF-8' dict ( header ) # output: {'text/html': None, 'charset': 'UTF-8'} Setup If you wish to run bellow examples, first do : from kiss_headers import parse_it from requests import get headers = parse_it ( get ( 'https://www.python.org' )) Check existence of an attribute in header Choose any flavour you like when checking for an attribute like charset=utf-8 . 'charset' in headers . content_type # OR hasattr ( headers . content_type , 'charset' ) # OR headers . content_type . has ( 'charset' ) Accessing an attribute headers . content_type . charset # OR headers . content_type [ 'charset' ] # OR headers . content_type . get ( 'charset' ) Remove an attribute If attribute exists multiple times, this removes all entries. del headers . content_type . charset # OR del headers . content_type [ 'charset' ] Remove a member from it If adjective/member exists multiple times, this removes all entries. headers . content_type -= 'text/html' Create an attribute on the fly headers . content_type . charset = 'utf-8' # OR headers . content_type [ 'charset' ] = 'utf-8'","title":"Header"},{"location":"advanced-header/#header-class","text":"This class is used to represent a single header as an object. An Header can be casted to str , bytes and dict . Given this : from kiss_headers import Header header = Header ( \"Content-Type\" , \"text/html; charset=UTF-8\" ) str ( header ) # output: 'text/html; charset=UTF-8' repr ( header ) # output: 'Content-Type: text/html; charset=UTF-8' bytes ( header ) # output: b'Content-Type: text/html; charset=UTF-8' dict ( header ) # output: {'text/html': None, 'charset': 'UTF-8'}","title":"Header Class"},{"location":"advanced-header/#setup","text":"If you wish to run bellow examples, first do : from kiss_headers import parse_it from requests import get headers = parse_it ( get ( 'https://www.python.org' ))","title":"Setup"},{"location":"advanced-header/#check-existence-of-an-attribute-in-header","text":"Choose any flavour you like when checking for an attribute like charset=utf-8 . 'charset' in headers . content_type # OR hasattr ( headers . content_type , 'charset' ) # OR headers . content_type . has ( 'charset' )","title":"Check existence of an attribute in header"},{"location":"advanced-header/#accessing-an-attribute","text":"headers . content_type . charset # OR headers . content_type [ 'charset' ] # OR headers . content_type . get ( 'charset' )","title":"Accessing an attribute"},{"location":"advanced-header/#remove-an-attribute","text":"If attribute exists multiple times, this removes all entries. del headers . content_type . charset # OR del headers . content_type [ 'charset' ]","title":"Remove an attribute"},{"location":"advanced-header/#remove-a-member-from-it","text":"If adjective/member exists multiple times, this removes all entries. headers . content_type -= 'text/html'","title":"Remove a member from it"},{"location":"advanced-header/#create-an-attribute-on-the-fly","text":"headers . content_type . charset = 'utf-8' # OR headers . content_type [ 'charset' ] = 'utf-8'","title":"Create an attribute on the fly"},{"location":"advanced-headers/","text":"Headers Class Object-oriented representation for Headers. Contains a list of Header with some level of abstraction. Combine advantages of dict, CaseInsensibleDict, list, multi-dict, and native objects. Headers do not inherit the Mapping type, but it does borrow some concepts from it. A Headers can be casted to str , bytes and dict . Given this : from kiss_headers import Headers , Header headers = Headers ( Header ( \"Content-Type\" , \"application/json\" ), Header ( \"Allow\" , \"POST\" ), Header ( \"Accept\" , \"text/html,application/json;q=0.8\" )) str ( headers ) # output: 'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' repr ( headers ) # output: 'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' bytes ( headers ) # output: b'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' dict ( headers ) # output: {'Content-Type': Content-Type: application/json, 'Allow': Allow: POST, 'Accept': Accept: text/html,application/json;q=0.8} headers . to_dict () # output: {'Content-Type': 'application/json', 'Allow': 'POST', 'Accept': 'text/html,application/json;q=0.8'} Setup If you wish to run bellow examples, first do : from kiss_headers import parse_it from requests import get headers = parse_it ( get ( 'https://www.python.org' )) Check for existence of a header 'Content-Type' in headers # OR 'Content-Type' in headers . keys () # OR hasattr ( headers , 'content-type' ) # OR headers . has ( 'content-type' ) Accessing a header headers . content_type # OR headers [ 'content-type' ] # OR headers . get ( 'content-type' ) Removing the header It is possible to remove an header in multiple ways. e.g. If you would like to remove Content-Type header. Using del del headers [ 'Content-Type' ] # OR del headers . content_type Using native subtract headers -= 'Content-Type' # OR headers = headers - 'Content-Type' Adding a header It is possible to add an header in multiple ways. eg. If you would like to add Content-Type header. You will have to import the Header class, in addition to parse_it , as done below. from kiss_headers import Header Using native addition headers += Header ( 'Content-Type' , 'application/json' ) Using assignments headers [ 'content-type' ] = 'application/json' # OR headers . content_type = 'application/json' Compare content Consider this : Content-Type content is application/json; charset=utf-8 . The following would result in a True statement. headers . content_type == 'application/json' 'application/json' in headers . content_type 'charset' in headers . content_type The following would result in a False statement. headers . content_type == 'application' 'application' in headers . content_type Cast to dict You could use to_dict() method to obtain a CaseInsensibleDict from a Headers object. Any headers that are OneToMany will be concatenated into one entry, separated with a comma. You could also directly cast a Headers instance to dict using dict(headers) , the values are of type Union[Header, List[Header]] . Keys won\u2019t be case insensitive.","title":"Headers"},{"location":"advanced-headers/#headers-class","text":"Object-oriented representation for Headers. Contains a list of Header with some level of abstraction. Combine advantages of dict, CaseInsensibleDict, list, multi-dict, and native objects. Headers do not inherit the Mapping type, but it does borrow some concepts from it. A Headers can be casted to str , bytes and dict . Given this : from kiss_headers import Headers , Header headers = Headers ( Header ( \"Content-Type\" , \"application/json\" ), Header ( \"Allow\" , \"POST\" ), Header ( \"Accept\" , \"text/html,application/json;q=0.8\" )) str ( headers ) # output: 'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' repr ( headers ) # output: 'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' bytes ( headers ) # output: b'Content-Type: application/json\\r\\nAllow: POST\\r\\nAccept: text/html,application/json;q=0.8' dict ( headers ) # output: {'Content-Type': Content-Type: application/json, 'Allow': Allow: POST, 'Accept': Accept: text/html,application/json;q=0.8} headers . to_dict () # output: {'Content-Type': 'application/json', 'Allow': 'POST', 'Accept': 'text/html,application/json;q=0.8'}","title":"Headers Class"},{"location":"advanced-headers/#setup","text":"If you wish to run bellow examples, first do : from kiss_headers import parse_it from requests import get headers = parse_it ( get ( 'https://www.python.org' ))","title":"Setup"},{"location":"advanced-headers/#check-for-existence-of-a-header","text":"'Content-Type' in headers # OR 'Content-Type' in headers . keys () # OR hasattr ( headers , 'content-type' ) # OR headers . has ( 'content-type' )","title":"Check for existence of a header"},{"location":"advanced-headers/#accessing-a-header","text":"headers . content_type # OR headers [ 'content-type' ] # OR headers . get ( 'content-type' )","title":"Accessing a header"},{"location":"advanced-headers/#removing-the-header","text":"It is possible to remove an header in multiple ways. e.g. If you would like to remove Content-Type header.","title":"Removing the header"},{"location":"advanced-headers/#using-del","text":"del headers [ 'Content-Type' ] # OR del headers . content_type","title":"Using del"},{"location":"advanced-headers/#using-native-subtract","text":"headers -= 'Content-Type' # OR headers = headers - 'Content-Type'","title":"Using native subtract"},{"location":"advanced-headers/#adding-a-header","text":"It is possible to add an header in multiple ways. eg. If you would like to add Content-Type header. You will have to import the Header class, in addition to parse_it , as done below. from kiss_headers import Header","title":"Adding a header"},{"location":"advanced-headers/#using-native-addition","text":"headers += Header ( 'Content-Type' , 'application/json' )","title":"Using native addition"},{"location":"advanced-headers/#using-assignments","text":"headers [ 'content-type' ] = 'application/json' # OR headers . content_type = 'application/json'","title":"Using assignments"},{"location":"advanced-headers/#compare-content","text":"Consider this : Content-Type content is application/json; charset=utf-8 . The following would result in a True statement. headers . content_type == 'application/json' 'application/json' in headers . content_type 'charset' in headers . content_type The following would result in a False statement. headers . content_type == 'application' 'application' in headers . content_type","title":"Compare content"},{"location":"advanced-headers/#cast-to-dict","text":"You could use to_dict() method to obtain a CaseInsensibleDict from a Headers object. Any headers that are OneToMany will be concatenated into one entry, separated with a comma. You could also directly cast a Headers instance to dict using dict(headers) , the values are of type Union[Header, List[Header]] . Keys won\u2019t be case insensitive.","title":"Cast to dict"},{"location":"contributing/","text":"Contribution Guidelines If you\u2019re reading this, you\u2019re probably interested in contributing to kiss-headers . Thank you very much! Open source projects thrive based on the support they receive from others, and the fact that you\u2019re even considering contributing to this project is very generous of you. Questions The GitHub issue tracker is for bug reports and feature requests . Questions are allowed only when no answer are provided in docs. Good Bug Reports Please be aware of the following things when filing bug reports: Avoid raising duplicate issues. Please use the GitHub issue search feature to check whether your bug report or feature request has been mentioned in the past. Duplicate bug reports and feature requests are a huge maintenance burden on the limited resources of the project. If it is clear from your report that you would have struggled to find the original, that\u2019s ok, but if searching for a selection of words in your issue title would have found the duplicate then the issue will likely be closed extremely abruptly. When filing bug reports about exceptions or tracebacks, please include the complete traceback. Partial tracebacks, or just the exception text, are not helpful. Issues that do not contain complete tracebacks may be closed without warning. Make sure you provide a suitable amount of information to work with. This means you should provide: Guidance on how to reproduce the issue . Ideally, this should be a small code sample that can be run immediately by the maintainers. Failing that, let us know what you\u2019re doing, how often it happens, what environment you\u2019re using, etc. Be thorough: it prevents us needing to ask further questions. Tell us what you expected to happen . When we run your example code, what are we expecting to happen? What does \u201csuccess\u201d look like for your code? Tell us what actually happens . It\u2019s not helpful for you to say \u201cit doesn\u2019t work\u201d or \u201cit fails\u201d. Tell us how it fails: do you get an exception? A None answer? How was the actual result different from your expected result? Tell us what version of kiss-headers you\u2019re using , and how you installed it . Different versions of kiss-headers behave differently and have different bugs. If you do not provide all of these things, it will take us much longer to fix your problem. If we ask you to clarify these and you never respond, we will close your issue without fixing it.","title":"Contributing"},{"location":"contributing/#contribution-guidelines","text":"If you\u2019re reading this, you\u2019re probably interested in contributing to kiss-headers . Thank you very much! Open source projects thrive based on the support they receive from others, and the fact that you\u2019re even considering contributing to this project is very generous of you.","title":"Contribution Guidelines"},{"location":"contributing/#questions","text":"The GitHub issue tracker is for bug reports and feature requests . Questions are allowed only when no answer are provided in docs.","title":"Questions"},{"location":"contributing/#good-bug-reports","text":"Please be aware of the following things when filing bug reports: Avoid raising duplicate issues. Please use the GitHub issue search feature to check whether your bug report or feature request has been mentioned in the past. Duplicate bug reports and feature requests are a huge maintenance burden on the limited resources of the project. If it is clear from your report that you would have struggled to find the original, that\u2019s ok, but if searching for a selection of words in your issue title would have found the duplicate then the issue will likely be closed extremely abruptly. When filing bug reports about exceptions or tracebacks, please include the complete traceback. Partial tracebacks, or just the exception text, are not helpful. Issues that do not contain complete tracebacks may be closed without warning. Make sure you provide a suitable amount of information to work with. This means you should provide: Guidance on how to reproduce the issue . Ideally, this should be a small code sample that can be run immediately by the maintainers. Failing that, let us know what you\u2019re doing, how often it happens, what environment you\u2019re using, etc. Be thorough: it prevents us needing to ask further questions. Tell us what you expected to happen . When we run your example code, what are we expecting to happen? What does \u201csuccess\u201d look like for your code? Tell us what actually happens . It\u2019s not helpful for you to say \u201cit doesn\u2019t work\u201d or \u201cit fails\u201d. Tell us how it fails: do you get an exception? A None answer? How was the actual result different from your expected result? Tell us what version of kiss-headers you\u2019re using , and how you installed it . Different versions of kiss-headers behave differently and have different bugs. If you do not provide all of these things, it will take us much longer to fix your problem. If we ask you to clarify these and you never respond, we will close your issue without fixing it.","title":"Good Bug Reports"},{"location":"explain-headers/","text":"Explain Headers This library ship with the function explain() that would allows you to get a short explanation for each distinct Header (On Name) in Headers. from kiss_headers import parse_it , explain from requests import get from pprint import pprint if __name__ == \"__main__\" : headers = parse_it ( get ( \"https://www.python.org\" )) pprint ( explain ( headers )) The function explain return a CaseInsensibleDict . Expected result from before code : Hint Explanations are extracted from available docstring of subclasses of Header . If non-existent would return \u2018Unknown explanation.\u2019 {'Accept-Ranges': 'Unknown explanation.', 'Age': 'Unknown explanation.', 'Connection': 'The Connection general header controls whether or not the ' 'network connection stays open after the current transaction ' 'finishes. If the value sent is keep-alive, the connection is ' 'persistent and not closed, allowing for subsequent requests to ' 'the same server to be done.', 'Content-Length': 'The Content-Length entity header indicates the size of the ' 'entity-body, in bytes, sent to the recipient.', 'Content-Type': 'The Content-Type entity header is used to indicate the media ' 'type of the resource. In responses, a Content-Type header ' 'tells the client what the content type of the returned ' 'content actually is. Browsers will do MIME sniffing in some ' 'cases and will not necessarily follow the value of this ' 'header; to prevent this behavior, the header ' 'X-Content-Type-Options can be set to nosniff.', 'Date': 'The Date general HTTP header contains the date and time at which the ' 'message was originated.', 'Server': 'The Server header describes the software used by the origin server ' 'that handled the request \u2014 that is, the server that generated the ' 'response.', 'Strict-Transport-Security': 'The HTTP Strict-Transport-Security response ' 'header (often abbreviated as HSTS) lets a web ' 'site tell browsers that it should only be ' 'accessed using HTTPS, instead of using HTTP.', 'Vary': 'The Vary HTTP response header determines how to match future request ' 'headers to decide whether a cached response can be used rather than ' 'requesting a fresh one from the origin server.', 'Via': 'Unknown explanation.', 'X-Cache': 'Unknown explanation.', 'X-Cache-Hits': 'Unknown explanation.', 'X-Frame-Options': 'The X-Frame-Options HTTP response header can be used to ' 'indicate whether or not a browser should be allowed to ' 'render a page in a <frame>, <iframe>, <embed> or ' '<object>. Sites can use this to avoid clickjacking ' 'attacks, by ensuring that their content is not embedded ' 'into other sites.', 'X-Served-By': 'Unknown explanation.', 'X-Timer': 'Unknown explanation.'}","title":"Explain Headers"},{"location":"explain-headers/#explain-headers","text":"This library ship with the function explain() that would allows you to get a short explanation for each distinct Header (On Name) in Headers. from kiss_headers import parse_it , explain from requests import get from pprint import pprint if __name__ == \"__main__\" : headers = parse_it ( get ( \"https://www.python.org\" )) pprint ( explain ( headers )) The function explain return a CaseInsensibleDict . Expected result from before code : Hint Explanations are extracted from available docstring of subclasses of Header . If non-existent would return \u2018Unknown explanation.\u2019 {'Accept-Ranges': 'Unknown explanation.', 'Age': 'Unknown explanation.', 'Connection': 'The Connection general header controls whether or not the ' 'network connection stays open after the current transaction ' 'finishes. If the value sent is keep-alive, the connection is ' 'persistent and not closed, allowing for subsequent requests to ' 'the same server to be done.', 'Content-Length': 'The Content-Length entity header indicates the size of the ' 'entity-body, in bytes, sent to the recipient.', 'Content-Type': 'The Content-Type entity header is used to indicate the media ' 'type of the resource. In responses, a Content-Type header ' 'tells the client what the content type of the returned ' 'content actually is. Browsers will do MIME sniffing in some ' 'cases and will not necessarily follow the value of this ' 'header; to prevent this behavior, the header ' 'X-Content-Type-Options can be set to nosniff.', 'Date': 'The Date general HTTP header contains the date and time at which the ' 'message was originated.', 'Server': 'The Server header describes the software used by the origin server ' 'that handled the request \u2014 that is, the server that generated the ' 'response.', 'Strict-Transport-Security': 'The HTTP Strict-Transport-Security response ' 'header (often abbreviated as HSTS) lets a web ' 'site tell browsers that it should only be ' 'accessed using HTTPS, instead of using HTTP.', 'Vary': 'The Vary HTTP response header determines how to match future request ' 'headers to decide whether a cached response can be used rather than ' 'requesting a fresh one from the origin server.', 'Via': 'Unknown explanation.', 'X-Cache': 'Unknown explanation.', 'X-Cache-Hits': 'Unknown explanation.', 'X-Frame-Options': 'The X-Frame-Options HTTP response header can be used to ' 'indicate whether or not a browser should be allowed to ' 'render a page in a <frame>, <iframe>, <embed> or ' '<object>. Sites can use this to avoid clickjacking ' 'attacks, by ensuring that their content is not embedded ' 'into other sites.', 'X-Served-By': 'Unknown explanation.', 'X-Timer': 'Unknown explanation.'}","title":"Explain Headers"},{"location":"imap/","text":"Usage with email, message (IMAP4) Usage of kiss-headers is pretty much the same. You can do the following : from kiss_headers import parse_it raw_content = open ( 'my-email.eml' , 'rb' ) . read () headers = parse_it ( raw_content ) Hint As seen previously, the library tend to separate \u201csquashed\u201d content into multiple entries. This behaviour has been restricted for the \u201cSubject\u201d header as its human written.","title":"Email"},{"location":"imap/#usage-with-email-message-imap4","text":"Usage of kiss-headers is pretty much the same. You can do the following : from kiss_headers import parse_it raw_content = open ( 'my-email.eml' , 'rb' ) . read () headers = parse_it ( raw_content ) Hint As seen previously, the library tend to separate \u201csquashed\u201d content into multiple entries. This behaviour has been restricted for the \u201cSubject\u201d header as its human written.","title":"Usage with email, message (IMAP4)"},{"location":"polymorphism/","text":"Polymorphism Sometimes we get extra lazy, kiss-headers provide two bases classes, named Header and Headers . When handling Header object we might want to do more complex things than extracting an attribute value. The library proposes more than 40+ ready-to-use custom Header subclasses with specifics methods associated. Transformation Since version 2.1 you can transform an Header object to its target CustomHeader subclass in order to access more methods. from kiss_headers import parse_it , get_polymorphic , SetCookie my_cookies = \"\"\"set-cookie: 1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT; path=/; domain=.google.fr; Secure; SameSite=none set-cookie: CONSENT=WP.284b10; expires=Fri, 01-Jan-2038 00:00:00 GMT; path=/; domain=.google.fr\"\"\" headers = parse_it ( my_cookies ) type ( headers . set_cookie [ 0 ]) # output: Header set_cookie = get_polymorphic ( headers . set_cookie [ 0 ], SetCookie ) type ( set_cookie ) # output: SetCookie set_cookie . get_cookie_name () # output: 1P_JAR set_cookie . get_expire () # output: datetime(...) See complete list of supported subclasses in Developer Interface .","title":"Polymorphism"},{"location":"polymorphism/#polymorphism","text":"Sometimes we get extra lazy, kiss-headers provide two bases classes, named Header and Headers . When handling Header object we might want to do more complex things than extracting an attribute value. The library proposes more than 40+ ready-to-use custom Header subclasses with specifics methods associated.","title":"Polymorphism"},{"location":"polymorphism/#transformation","text":"Since version 2.1 you can transform an Header object to its target CustomHeader subclass in order to access more methods. from kiss_headers import parse_it , get_polymorphic , SetCookie my_cookies = \"\"\"set-cookie: 1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT; path=/; domain=.google.fr; Secure; SameSite=none set-cookie: CONSENT=WP.284b10; expires=Fri, 01-Jan-2038 00:00:00 GMT; path=/; domain=.google.fr\"\"\" headers = parse_it ( my_cookies ) type ( headers . set_cookie [ 0 ]) # output: Header set_cookie = get_polymorphic ( headers . set_cookie [ 0 ], SetCookie ) type ( set_cookie ) # output: SetCookie set_cookie . get_cookie_name () # output: 1P_JAR set_cookie . get_expire () # output: datetime(...) See complete list of supported subclasses in Developer Interface .","title":"Transformation"},{"location":"quickstart/","text":"Using parse_it The most common thing you\u2019d do is to parse raw headers and turn them to objects. parse_it() method takes bytes , str , fp , dict , email.Message , requests.Response and httpx._models.Response itself and returns a Headers object. from requests import get from kiss_headers import parse_it response = get ( 'https://www.google.fr' ) headers = parse_it ( response ) headers . content_type . charset # output: ISO-8859-1 OneToOne, OneToMany Do not forget that headers are not 1 to 1. One header can be repeated multiple times and attributes can have multiple values within the same header. from kiss_headers import parse_it my_cookies = \"\"\"set-cookie: 1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT; path=/; domain=.google.fr; Secure; SameSite=none set-cookie: CONSENT=WP.284b10; expires=Fri, 01-Jan-2038 00:00:00 GMT; path=/; domain=.google.fr\"\"\" headers = parse_it ( my_cookies ) type ( headers . set_cookie ) # output: list headers . set_cookie [ 0 ] . expires # output Wed, 15-Apr-2020 21:27:31 GMT ManySquashedIntoOne There is an edge case ( Not only Set-Cookie ) where one header content could contain multiple entries (usually) separated by a comma. Take the Accept header for instance. Accept : text /html, application/xhtml+xml, application/xml;q=0.9, image/webp, */ *; q = 0.8 The library will split this entry into five entries/headers/objects. from kiss_headers import parse_it headers = parse_it ( \"Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8\" ) len ( headers ) # output: 5 headers . has_many ( \"accept\" ) # output: True len ( headers . accept ) # output: 5 repr ( headers . accept [ 0 ]) # output: 'Accept: text/html' repr ( headers . accept [ 3 ]) # output: 'Accept: application/xml;q=0.9' # What if we want to verify that text/html is available in Accept ? \"text/html\" in headers . accept # output: True \"text/htm\" in headers . accept # output: False # How to extract the qualifier ? headers . accept [ 0 ] . has ( \"q\" ) # output: False \"q\" in headers . accept [ 0 ] # output: False headers . accept [ 3 ] . has ( \"q\" ) # output: True \"q\" in headers . accept [ 3 ] # output: True headers . accept [ 3 ][ \"q\" ] # output: 0.9 This behavior is global to all headers. Using protected keyword Just a note: Accessing a header that has the same name as a reserved keyword must be done this way : from kiss_headers import parse_it headers = parse_it ( 'From: Ousret; origin=www.github.com \\n IS: 1 \\n While: Not-True' ) # this flavour headers . from_ # to access From, just add a single underscore to it # or.. headers [ 'from' ] Lock the output type entropy You might not like that some functions/methods in Header and Headers classes return type-hint is Union[Header, List[Header]] . There is a quick way to enforce the return type to List[Header] only. from kiss_headers import lock_output_type lock_output_type ( True )","title":"Quick Start"},{"location":"quickstart/#using-parse_it","text":"The most common thing you\u2019d do is to parse raw headers and turn them to objects. parse_it() method takes bytes , str , fp , dict , email.Message , requests.Response and httpx._models.Response itself and returns a Headers object. from requests import get from kiss_headers import parse_it response = get ( 'https://www.google.fr' ) headers = parse_it ( response ) headers . content_type . charset # output: ISO-8859-1","title":"Using parse_it"},{"location":"quickstart/#onetoone-onetomany","text":"Do not forget that headers are not 1 to 1. One header can be repeated multiple times and attributes can have multiple values within the same header. from kiss_headers import parse_it my_cookies = \"\"\"set-cookie: 1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT; path=/; domain=.google.fr; Secure; SameSite=none set-cookie: CONSENT=WP.284b10; expires=Fri, 01-Jan-2038 00:00:00 GMT; path=/; domain=.google.fr\"\"\" headers = parse_it ( my_cookies ) type ( headers . set_cookie ) # output: list headers . set_cookie [ 0 ] . expires # output Wed, 15-Apr-2020 21:27:31 GMT","title":"OneToOne, OneToMany"},{"location":"quickstart/#manysquashedintoone","text":"There is an edge case ( Not only Set-Cookie ) where one header content could contain multiple entries (usually) separated by a comma. Take the Accept header for instance. Accept : text /html, application/xhtml+xml, application/xml;q=0.9, image/webp, */ *; q = 0.8 The library will split this entry into five entries/headers/objects. from kiss_headers import parse_it headers = parse_it ( \"Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8\" ) len ( headers ) # output: 5 headers . has_many ( \"accept\" ) # output: True len ( headers . accept ) # output: 5 repr ( headers . accept [ 0 ]) # output: 'Accept: text/html' repr ( headers . accept [ 3 ]) # output: 'Accept: application/xml;q=0.9' # What if we want to verify that text/html is available in Accept ? \"text/html\" in headers . accept # output: True \"text/htm\" in headers . accept # output: False # How to extract the qualifier ? headers . accept [ 0 ] . has ( \"q\" ) # output: False \"q\" in headers . accept [ 0 ] # output: False headers . accept [ 3 ] . has ( \"q\" ) # output: True \"q\" in headers . accept [ 3 ] # output: True headers . accept [ 3 ][ \"q\" ] # output: 0.9 This behavior is global to all headers.","title":"ManySquashedIntoOne"},{"location":"quickstart/#using-protected-keyword","text":"Just a note: Accessing a header that has the same name as a reserved keyword must be done this way : from kiss_headers import parse_it headers = parse_it ( 'From: Ousret; origin=www.github.com \\n IS: 1 \\n While: Not-True' ) # this flavour headers . from_ # to access From, just add a single underscore to it # or.. headers [ 'from' ]","title":"Using protected keyword"},{"location":"quickstart/#lock-the-output-type-entropy","text":"You might not like that some functions/methods in Header and Headers classes return type-hint is Union[Header, List[Header]] . There is a quick way to enforce the return type to List[Header] only. from kiss_headers import lock_output_type lock_output_type ( True )","title":"Lock the output type entropy"},{"location":"the-builder/","text":"Build headers This library also permits you to create headers using ready-to-use classes. Use it for your HTTP request from kiss_headers import Headers , Authorization from requests import get response = get ( \"https://httpbin.org/bearer\" , headers = Headers ( Authorization ( \"Bearer\" , \"qwerty\" ))) print ( response . status_code ) # 200 Create raw headers from objects from kiss_headers import * headers = ( Host ( \"developer.mozilla.org\" ) + UserAgent ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\" ) + Accept ( \"text/html\" ) + Accept ( \"application/xhtml+xml\" ) + Accept ( \"application/xml\" , qualifier = 0.9 ) + Accept ( qualifier = 0.8 ) + AcceptLanguage ( \"en-US\" ) + AcceptLanguage ( \"en\" , qualifier = 0.5 ) + AcceptEncoding ( \"gzip\" ) + AcceptEncoding ( \"deflate\" ) + AcceptEncoding ( \"br\" ) + Referer ( \"https://developer.mozilla.org/testpage.html\" ) + Connection ( should_keep_alive = True ) + UpgradeInsecureRequests () + IfModifiedSince ( \"Mon, 18 Jul 2016 02:36:04 GMT\" ) + IfNoneMatch ( \"c561c68d0ba92bbeb8b0fff2a9199f722e3a621a\" ) + CacheControl ( max_age = 0 ) ) raw_headers = str ( headers ) raw_headers now retain the following : Host : developer . mozilla . org User - Agent : Mozilla /5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/ 50.0 Accept : text /html, application/xhtml+xml, application/xml; q=\"0.9\", */ *; q = \"0.8\" Accept - Language : en - US , en ; q = \"0.5\" Accept - Encoding : gzip , deflate , br Referer : https :// developer . mozilla . org / testpage . html Connection : keep - alive Upgrade - Insecure - Requests : 1 If - Modified - Since : Mon , 18 Jul 2016 02 : 36 : 04 GMT If - None - Match : \"c561c68d0ba92bbeb8b0fff2a9199f722e3a621a\" Cache - Control : max - age = \"0\" See the complete list of available header class in the full documentation. Create yours Also, you can create your own custom header object using the class kiss_headers.CustomHeader . from kiss_headers import CustomHeader class MyExtraHeader ( CustomHeader ): \"\"\"My extra header purpose is to...\"\"\" __squash__ = False # Determine if multiple instance of MyExtraHeader should be squashed into one entry using coma. __override__ = None # Replace it by a string if the default \"class to header name\" does suit you. # Here MyExtraHeader class would be named 'My-Extra-Header'. def __init__ ( self , checksum : str , param_1 : str ): super () . __init__ ( checksum , ** { \"param_1\" : param_1 }) Now you can instance MyExtraHeader like this : header = MyExtraHeader ( \"azerty\" , param_1 = \"abc\" ) repr ( header ) # output: 'My-Extra-Header: azerty; param_1=\"abc\"' Note You can implement your own methods in a CustomHeader subclass but you cannot create properties, attributes as this behavior (get/set) is overridden by the library.","title":"The Builder"},{"location":"the-builder/#build-headers","text":"This library also permits you to create headers using ready-to-use classes.","title":"Build headers"},{"location":"the-builder/#use-it-for-your-http-request","text":"from kiss_headers import Headers , Authorization from requests import get response = get ( \"https://httpbin.org/bearer\" , headers = Headers ( Authorization ( \"Bearer\" , \"qwerty\" ))) print ( response . status_code ) # 200","title":"Use it for your HTTP request"},{"location":"the-builder/#create-raw-headers-from-objects","text":"from kiss_headers import * headers = ( Host ( \"developer.mozilla.org\" ) + UserAgent ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\" ) + Accept ( \"text/html\" ) + Accept ( \"application/xhtml+xml\" ) + Accept ( \"application/xml\" , qualifier = 0.9 ) + Accept ( qualifier = 0.8 ) + AcceptLanguage ( \"en-US\" ) + AcceptLanguage ( \"en\" , qualifier = 0.5 ) + AcceptEncoding ( \"gzip\" ) + AcceptEncoding ( \"deflate\" ) + AcceptEncoding ( \"br\" ) + Referer ( \"https://developer.mozilla.org/testpage.html\" ) + Connection ( should_keep_alive = True ) + UpgradeInsecureRequests () + IfModifiedSince ( \"Mon, 18 Jul 2016 02:36:04 GMT\" ) + IfNoneMatch ( \"c561c68d0ba92bbeb8b0fff2a9199f722e3a621a\" ) + CacheControl ( max_age = 0 ) ) raw_headers = str ( headers ) raw_headers now retain the following : Host : developer . mozilla . org User - Agent : Mozilla /5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/ 50.0 Accept : text /html, application/xhtml+xml, application/xml; q=\"0.9\", */ *; q = \"0.8\" Accept - Language : en - US , en ; q = \"0.5\" Accept - Encoding : gzip , deflate , br Referer : https :// developer . mozilla . org / testpage . html Connection : keep - alive Upgrade - Insecure - Requests : 1 If - Modified - Since : Mon , 18 Jul 2016 02 : 36 : 04 GMT If - None - Match : \"c561c68d0ba92bbeb8b0fff2a9199f722e3a621a\" Cache - Control : max - age = \"0\" See the complete list of available header class in the full documentation.","title":"Create raw headers from objects"},{"location":"the-builder/#create-yours","text":"Also, you can create your own custom header object using the class kiss_headers.CustomHeader . from kiss_headers import CustomHeader class MyExtraHeader ( CustomHeader ): \"\"\"My extra header purpose is to...\"\"\" __squash__ = False # Determine if multiple instance of MyExtraHeader should be squashed into one entry using coma. __override__ = None # Replace it by a string if the default \"class to header name\" does suit you. # Here MyExtraHeader class would be named 'My-Extra-Header'. def __init__ ( self , checksum : str , param_1 : str ): super () . __init__ ( checksum , ** { \"param_1\" : param_1 }) Now you can instance MyExtraHeader like this : header = MyExtraHeader ( \"azerty\" , param_1 = \"abc\" ) repr ( header ) # output: 'My-Extra-Header: azerty; param_1=\"abc\"' Note You can implement your own methods in a CustomHeader subclass but you cannot create properties, attributes as this behavior (get/set) is overridden by the library.","title":"Create yours"},{"location":"the-theory/","text":"The theory Headers are kind of complicated, so many RFCs to study, so many forms to comprehend. This package offers the possibility to handle most of the forms you could encounter. So, after my researches on Mozilla MDN and IETF websites, I have elaborated a new way to handle them. Roots concepts Bases What you should know before getting started : Content-Type: text/html ; charset =UTF-8 Here text/html is a member of Content-Type , also charset is an attribute and its associated with the value UTF-8 . TL;DR Provided models, Headers and Header does not inherit from Mapping nor does it from List . Some package prefers to inherit from them, we do not. In most headers, the semi-colon ; character is used as a separator. But you can also see some headers using a single comma , as a separator. Here\u2019s how I understand those two separators. The single comma indicate that their is multiple entries for the same headers. The semi-colon separate members inside the same entry and therefor cannot be interpreted separately. Writing Accept: text/html, application/json;q=0.8 is another way to write : Accept : text / html Accept : application / json ; q = 0.8 Cases In this project case insensitive mean no distinction between lower and upper letters plus the character - eq _ . The header name is case insensitive. Every member of an header is case insensitive except the value associated with an attribute.","title":"The Theory"},{"location":"the-theory/#the-theory","text":"Headers are kind of complicated, so many RFCs to study, so many forms to comprehend. This package offers the possibility to handle most of the forms you could encounter. So, after my researches on Mozilla MDN and IETF websites, I have elaborated a new way to handle them.","title":"The theory"},{"location":"the-theory/#roots-concepts","text":"","title":"Roots concepts"},{"location":"the-theory/#bases","text":"What you should know before getting started : Content-Type: text/html ; charset =UTF-8 Here text/html is a member of Content-Type , also charset is an attribute and its associated with the value UTF-8 . TL;DR Provided models, Headers and Header does not inherit from Mapping nor does it from List . Some package prefers to inherit from them, we do not. In most headers, the semi-colon ; character is used as a separator. But you can also see some headers using a single comma , as a separator. Here\u2019s how I understand those two separators. The single comma indicate that their is multiple entries for the same headers. The semi-colon separate members inside the same entry and therefor cannot be interpreted separately. Writing Accept: text/html, application/json;q=0.8 is another way to write : Accept : text / html Accept : application / json ; q = 0.8","title":"Bases"},{"location":"the-theory/#cases","text":"In this project case insensitive mean no distinction between lower and upper letters plus the character - eq _ . The header name is case insensitive. Every member of an header is case insensitive except the value associated with an attribute.","title":"Cases"},{"location":"APIs/custom-headers/","text":"Module kiss_headers.builder Classes Class Accept class Accept(mime: str = '*/*', qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. Using content negotiation, the server then selects one of the proposals, uses it and informs the client of its choice with the Content-Type response header. :param mime: Describe the MIME using this syntax :param qualifier: Any value used is placed in an order of preference expressed using relative quality value called the weight. :param kwargs: header = Accept ( \"text/html\" , qualifier = 0.8 ) header . content 'text/html; q=\"0.8\"' repr ( header ) 'Accept: text/html; q=\"0.8\"' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_mime def get_mime(self) -> Union[str, NoneType] Return defined mime in current accept header. Method get_qualifier def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified mime. If not set, output 1.0. Class AcceptEncoding class AcceptEncoding(method: str, qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept-Encoding request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using content negotiation, the server selects one of the proposals, uses it and informs the client of its choice with the Content-Encoding response header. :param method: Either chunked, compress, deflate, gzip, identity, br or a wildcard. :param qualifier: Any value used is placed in an order of preference expressed using relative quality value called the weight. :param kwargs: Ancestors (in MRO) kiss_headers.builder.TransferEncoding kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_qualifier def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified encoding. If not set, output 1.0. Class AcceptLanguage class AcceptLanguage(language: str = '*', qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept-Language request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) :param language: A language tag (which is sometimes referred to as a \u201clocale identifier\u201d). This consists of a 2-3 letter base language tag representing the language. :param qualifier: Any value placed in an order of preference expressed using a relative quality value called weight. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_qualifier def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified language. If not set, output 1.0. Class Allow class Allow(supported_verb: str, **kwargs: Union[str, NoneType]) The Allow header lists the set of methods supported by a resource. :param supported_verb: Choose exactly one of \u201cHEAD\u201d, \u201cGET\u201d, \u201cPOST\u201d, \u201cPUT\u201d, \u201cPATCH\u201d, \u201cDELETE\u201d, \u201cPURGE\u201d, \u201cCONNECT\u201d or \u201cTRACE\u201d HTTP verbs. :param kwargs: header = Allow ( \"POST\" ) repr ( header ) 'Allow: POST' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class AltSvc class AltSvc(protocol_id: str, alt_authority: str, max_age: Union[int, NoneType] = None, versions: Union[List[str], NoneType] = None, do_persist: Union[bool, NoneType] = None, **kwargs: Union[str, NoneType]) The Alt-Svc HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination. :param protocol_id: The ALPN protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol. :param alt_authority: The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number. :param max_age: The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. :param versions: List of supported versions of the protocol id if the protocol id can be ambiguous. (like QUIC) :param do_persist: Use the parameter to ensures that the entry is not deleted through network configuration changes. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_alt_authority def get_alt_authority(self) -> str Extract the alternative authority which consists of an optional host override, a colon, and a mandatory port number. Method get_max_age def get_max_age(self) -> Union[int, NoneType] Output the number of seconds for which the alternative service is considered fresh. None if undefined. Method get_protocol_id def get_protocol_id(self) -> str Get the ALPN protocol identifier. Method get_versions def get_versions(self) -> Union[List[str], NoneType] May return, if available, a list of versions of the ALPN protocol identifier. Method should_persist def should_persist(self) -> Union[bool, NoneType] Verify if the entry should not be deleted through network configuration changes. None if no indication. Class Authorization class Authorization(type_: str, credentials: str, **kwargs: Union[str, NoneType]) The HTTP Authorization request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a 401 Unauthorized status and the WWW-Authenticate header. :param type_: Authentication type. A common type is \u201cBasic\u201d. See IANA registry of Authentication schemes for others. :param credentials: Associated credentials to use. Preferably Base-64 encoded. header = Authorization ( \"Bearer\" , \"base64encoded\" ) repr ( header ) 'Authorization: Bearer base64encoded' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Descendants kiss_headers.builder.BasicAuthorization kiss_headers.builder.ProxyAuthorization Methods Method get_auth_type def get_auth_type(self) -> str Return the auth type used in Authorization. Method get_credentials def get_credentials(self) -> str Output the credentials. Class BasicAuthorization class BasicAuthorization(username: str, password: str, charset: str = 'latin1', **kwargs: Union[str, NoneType]) Same as Authorization header but simplified for the Basic method. Also an example of override usage. :param username: :param password: :param charset: By default, credentials are encoded using latin1 charset. You may want to choose otherwise. :param kwargs: header = BasicAuthorization ( \"azerty\" , \"qwerty\" ) header Authorization : Basic YXplcnR5OnF3ZXJ0eQ == header . get_username_password () ( 'azerty' , 'qwerty' ) Ancestors (in MRO) kiss_headers.builder.Authorization kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_credentials def get_credentials(self) -> str Decode base64 encoded credentials from Authorization header. Method get_username_password def get_username_password(self) -> Tuple[str, ...] Extract username and password as a tuple from Basic Authorization. Class CacheControl class CacheControl(directive: Union[str, NoneType] = None, max_age: Union[int, NoneType] = None, max_stale: Union[int, NoneType] = None, min_fresh: Union[int, NoneType] = None, s_maxage: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Cache-Control HTTP header holds directives (instructions) for caching in both requests and responses. A given directive in a request does not mean the same directive should be in the response. Pass only one parameter per CacheControl instance. :param directive: Could be one of must-revalidate, no-cache, no-store, no-transform, public, private, proxy-revalidate, only-if-cached, no-transform. :param max_age: The maximum amount of time a resource is considered fresh. Unlike Expires, this directive is relative to the time of the request. :param max_stale: Indicates the client will accept a stale response. An optional value in seconds indicates the upper limit of staleness the client will accept. :param min_fresh: Indicates the client wants a response that will still be fresh for at least the specified number of seconds. :param s_maxage: Overrides max-age or the Expires header, but only for shared caches (e.g., proxies). Ignored by private caches. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Connection class Connection(should_keep_alive: bool, **kwargs: Union[str, NoneType]) The Connection general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is keep-alive, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done. :param should_keep_alive: Indicates that the client would like to keep the connection open or not. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ContentDisposition class ContentDisposition(disposition: str = 'inline', name: Union[str, NoneType] = None, filename: Union[str, NoneType] = None, fallback_filename: Union[str, NoneType] = None, boundary: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) In a regular HTTP response, the Content-Disposition response header is a header indicating if the content is expected to be displayed inline in the browser, that is, as a Web page or as part of a Web page, or as an attachment, that is downloaded and saved locally. :param disposition: Could be either inline, form-data, attachment or empty. Choose one. Default to inline. :param name: Is a string containing the name of the HTML field in the form that the content of this subpart refers to. :param filename: Is a string containing the original name of the file transmitted. The filename is always optional and must not be used blindly by the application. ASCII-US Only. :param fallback_filename: Fallback filename if filename parameter does not uses the encoding defined in RFC 5987. :param boundary: For multipart entities the boundary directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ContentEncoding class ContentEncoding(method: str, **kwargs: Union[str, NoneType]) The Content-Encoding entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the Content-Type header. If multiple, keep them in the order in which they were applied. :param method: Either chunked, compress, deflate, gzip, identity or br. :param kwargs: Ancestors (in MRO) kiss_headers.builder.TransferEncoding kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ContentLength class ContentLength(length: int, **kwargs: Union[str, NoneType]) The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient. :param length: The length in decimal number of octets. Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ContentRange class ContentRange(unit: str, start: int, end: int, size: Union[str, int], **kwargs: Union[str, NoneType]) The Content-Range response HTTP header indicates where in a full body message a partial message belongs. :param unit: The unit in which ranges is specified. This is usually bytes. :param start: An integer in the given unit indicating the beginning of the request range. :param end: An integer in the given unit indicating the end of the requested range. :param size: The total size of the document (or \u2018*\u2019 if unknown). :param kwargs: header = ContentRange ( \"bytes\" , 0 , 1024 , 4096 ) repr ( header ) 'Content-Range: bytes 0-1024/4096' header . get_size () 4096 header . unpack () ( 'bytes' , '0' , '1024' , '4096' ) Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_end def get_end(self) -> int Get the end of the requested range. Method get_size def get_size(self) -> Union[str, int] Get the total size of the document (or \u2018*\u2019 if unknown). Method get_start def get_start(self) -> int Get the beginning of the request range. Method get_unit def get_unit(self) -> str Retrieve the unit in which ranges is specified. Method unpack def unpack(self) -> Tuple[str, str, str, str] Provide a basic way to parse ContentRange format. Class ContentSecurityPolicy class ContentSecurityPolicy(*policies: List[str]) Content-Security-Policy is the name of a HTTP response header that modern browsers use to enhance the security of the document (or web page). The Content-Security-Policy header allows you to restrict how resources such as JavaScript, CSS, or pretty much anything that the browser loads. :param policies: One policy consist of a list of str like [\u201cdefault-src\u201d, \u201c\u2018none\u2019\u201c]. header = ContentSecurityPolicy ([ \"default-src\" , \"'none'\" ], [ \"img-src\" , \"'self'\" , \"img.example.com\" ]) repr ( header ) \"Content-Security-Policy: default-src 'none'; img-src 'self' img.example.com\" header . get_policies_names () [ 'default-src' , 'img-src' ] header . get_policy_args ( \"img-src\" ) [ \"'self'\" , 'img.example.com' ] Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_policies_names def get_policies_names(self) -> List[str] Fetch a list of policy name set in content. Method get_policy_args def get_policy_args(self, policy_name: str) -> Union[List[str], NoneType] Retrieve given arguments for a policy. Class ContentType class ContentType(mime: str, charset: Union[str, NoneType] = None, format_: Union[str, NoneType] = None, boundary: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The Content-Type entity header is used to indicate the media type of the resource. In responses, a Content-Type header tells the client what the content type of the returned content actually is. Browsers will do MIME sniffing in some cases and will not necessarily follow the value of this header; to prevent this behavior, the header X-Content-Type-Options can be set to nosniff. :param mime_type: The MIME type of the resource or the data. Format / . :param charset: The character encoding standard. Should be an IANA name. :param format_: Mostly used in IMAP, could be one of : original or flowed. :param boundary: For multipart entities the boundary directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. :param kwargs: header = ContentType ( \"text/html\" , charset = \"utf-8\" ) repr ( header ) 'Content-Type: text/html; charset=\"UTF-8\"' header . get_charset () 'UTF-8' header . get_mime () 'text/html' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_charset def get_charset(self) -> Union[str, NoneType] Extract defined charset, if not present will return \u2018ISO-8859-1\u2019 by default. Method get_mime def get_mime(self) -> Union[str, NoneType] Return defined mime in content type. Class Cookie class Cookie(**kwargs: Union[str, NoneType]) The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header. :param kwargs: Pair of cookie name associated with a value. Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_cookie_value def get_cookie_value(self, cookie_name: str) -> Union[str, NoneType] Retrieve associated value with a given cookie name. Method get_cookies_names def get_cookies_names(self) -> List[str] Retrieve all defined cookie names from Cookie header. Class CrossOriginResourcePolicy class CrossOriginResourcePolicy(policy: str, **kwargs: Union[str, NoneType]) The HTTP Cross-Origin-Resource-Policy response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource. :param policy: Accepted values are same-site, same-origin or cross-origin. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class CustomHeader class CustomHeader(initial_content: str = '', **kwargs: Union[str, NoneType]) This class is a helper to create ready-to-use Header object with creation assistance. Should NOT be instantiated. Use this class as a direct parent for creating ready-to-use header object. Inspire yourself with already defined class bellow this one. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored. Ancestors (in MRO) kiss_headers.models.Header Descendants kiss_headers.builder.Accept kiss_headers.builder.AcceptLanguage kiss_headers.builder.Allow kiss_headers.builder.AltSvc kiss_headers.builder.Authorization kiss_headers.builder.CacheControl kiss_headers.builder.Connection kiss_headers.builder.ContentDisposition kiss_headers.builder.ContentLength kiss_headers.builder.ContentRange kiss_headers.builder.ContentSecurityPolicy kiss_headers.builder.ContentType kiss_headers.builder.Cookie kiss_headers.builder.CrossOriginResourcePolicy kiss_headers.builder.Date kiss_headers.builder.Digest kiss_headers.builder.Dnt kiss_headers.builder.Etag kiss_headers.builder.Forwarded kiss_headers.builder.From kiss_headers.builder.Host kiss_headers.builder.IfMatch kiss_headers.builder.KeepAlive kiss_headers.builder.Location kiss_headers.builder.Referer kiss_headers.builder.ReferrerPolicy kiss_headers.builder.Server kiss_headers.builder.SetCookie kiss_headers.builder.StrictTransportSecurity kiss_headers.builder.TransferEncoding kiss_headers.builder.UpgradeInsecureRequests kiss_headers.builder.UserAgent kiss_headers.builder.Vary kiss_headers.builder.WwwAuthenticate kiss_headers.builder.XContentTypeOptions kiss_headers.builder.XDnsPrefetchControl kiss_headers.builder.XFrameOptions kiss_headers.builder.XXssProtection Class Date class Date(my_date: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Date general HTTP header contains the date and time at which the message was originated. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Descendants kiss_headers.builder.Expires kiss_headers.builder.IfModifiedSince kiss_headers.builder.IfUnmodifiedSince kiss_headers.builder.LastModified kiss_headers.builder.RetryAfter Methods Method get_datetime def get_datetime(self) -> datetime.datetime Parse and return a datetime according to content. Class Digest class Digest(algorithm: str, value: str, **kwargs: Union[str, NoneType]) The Digest response HTTP header provides a digest of the requested resource. RFC 7231. :param algorithm: Supported digest algorithms are defined in RFC 3230 and RFC 5843, and include SHA-256 and SHA-512. :param value: The result of applying the digest algorithm to the resource representation and encoding the result. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Dnt class Dnt(tracking_consent: bool = False, **kwargs: Union[str, NoneType]) The DNT (Do Not Track) request header indicates the user\u2019s tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content. :param tracking_consent: The user prefers to allow tracking on the target site or not. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Etag class Etag(etag_value: str, is_a_weak_validator: bool = False, **kwargs: Union[str, NoneType]) The ETag HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. :param etag_value: Entity tag uniquely representing the requested resource. ASCII string only. Not quoted. :param is_a_weak_validator: Indicates that a weak validator is used. Weak etags are easy to generate, but are far less useful for comparisons. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Expires class Expires(datetime_or_custom: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Expires header contains the date/time after which the response is considered stale. Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs: Ancestors (in MRO) kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Forwarded class Forwarded(by: str, for_: str, using_proto: str, host: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The Forwarded header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request. :param by: The interface where the request came in to the proxy server. Could be an IP address, an obfuscated identifier or \u201cunknown\u201d. :param for_: The client that initiated the request and subsequent proxies in a chain of proxies. :param host: The Host request header field as received by the proxy. :param using_proto: Indicates which protocol was used to make the request (typically \u201chttp\u201d or \u201chttps\u201d). :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class From class From(email: str, **kwargs: Union[str, NoneType]) The From request header contains an Internet email address for a human user who controls the requesting user agent. If you are running a robotic user agent (e.g. a crawler), the From header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests. :param email: A machine-usable email address. See RFC 5322. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Host class Host(host: str, port: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Host request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening. :param host: The domain name of the server (for virtual hosting). :param port: TCP port number on which the server is listening. header = Host ( \"www.python.org\" ) repr ( header ) 'Host: www.python.org' header = Host ( \"www.python.org\" , port = 8000 ) repr ( header ) 'Host: www.python.org:8000' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class IfMatch class IfMatch(etag_value: str, **kwargs: Union[str, NoneType]) The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case. :param etag_value: Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like \u201c675af34563dc-tr34\u201d). :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Descendants kiss_headers.builder.IfNoneMatch Class IfModifiedSince class IfModifiedSince(dt: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The If-Modified-Since request HTTP header makes the request conditional :param dt: :param kwargs: Ancestors (in MRO) kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header Class IfNoneMatch class IfNoneMatch(etag_value: str, **kwargs: Union[str, NoneType]) The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if it doesn\u2019t have an ETag matching the given ones. For other methods, the request will be processed only if the eventually existing resource\u2019s ETag doesn\u2019t match any of the values listed. :param etag_value: Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like \u201c675af34563dc-tr34\u201d). :param kwargs: Ancestors (in MRO) kiss_headers.builder.IfMatch kiss_headers.builder.CustomHeader kiss_headers.models.Header Class IfUnmodifiedSince class IfUnmodifiedSince(dt: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The If-Unmodified-Since request HTTP header makes the request conditional :param dt: :param kwargs: Ancestors (in MRO) kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header Class KeepAlive class KeepAlive(timeout: Union[int, NoneType] = None, max_: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Keep-Alive general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests. :param timeout: indicating the minimum amount of time an idle connection has to be kept opened (in seconds). :param max: indicating the maximum number of requests that can be sent on this connection before closing it. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class LastModified class LastModified(my_date: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. :param my_date: :param kwargs: Ancestors (in MRO) kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Location class Location(uri: str, **kwargs: Union[str, NoneType]) The Location response header indicates the URL to redirect a page to. It only provides a meaning when served with a 3xx (redirection) or 201 (created) status response. :param uri: A relative (to the request URL) or absolute URL. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ProxyAuthorization class ProxyAuthorization(type_: str, credentials: str) The HTTP Proxy-Authorization request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a 407 Proxy Authentication Required status and the Proxy-Authenticate header. :param type_: Authentication type. A common type is \u201cBasic\u201d. See IANA registry of Authentication schemes for others. :param credentials: Associated credentials to use. Preferably Base-64 encoded. Ancestors (in MRO) kiss_headers.builder.Authorization kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Referer class Referer(url: str, **kwargs: Union[str, NoneType]) The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example. Note that referer is actually a misspelling of the word \u201creferrer\u201d. See https://en.wikipedia.org/wiki/HTTP_referer :param url: An absolute or partial address of the previous web page from which a link to the currently requested page was followed. URL fragments not included. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class ReferrerPolicy class ReferrerPolicy(policy: str, **kwargs: Union[str, NoneType]) The Referrer-Policy HTTP header controls how much referrer information (sent via the Referer header) should be included with requests. :param policy: Either \u201cno-referrer\u201d, \u201cno-referrer-when-downgrade\u201d, \u201corigin\u201d, \u201corigin-when-cross-origin\u201d, \u201csame-origin\u201d, \u201cstrict-origin\u201d, \u201cstrict-origin-when-cross-origin\u201d, \u201cunsafe-url\u201d :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class RetryAfter class RetryAfter(delay_or_date: Union[datetime.datetime, int], **kwargs: Union[str, NoneType]) The Retry-After response HTTP header indicates how long the user agent should wait before making a follow-up request. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs: Ancestors (in MRO) kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Server class Server(product: str, **kwargs: Union[str, NoneType]) The Server header describes the software used by the origin server that handled the request \u2014 that is, the server that generated the response. :param product: The name of the software or product that handled the request. Usually in a format similar to User-Agent. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class SetCookie class SetCookie(cookie_name: str, cookie_value: str, expires: Union[datetime.datetime, str, NoneType] = None, max_age: Union[int, NoneType] = None, domain: Union[str, NoneType] = None, path: Union[str, NoneType] = None, samesite: Union[str, NoneType] = None, is_secure: bool = False, is_httponly: bool = True, **kwargs: Union[str, NoneType]) The Set-Cookie HTTP response header is used to send cookies from the server to the user agent, so the user agent can send them back to the server later. :param cookie_name: Can be any US-ASCII characters, except control characters, spaces, or tabs. :param cookie_value: Can include any US-ASCII characters excluding control characters, Whitespace, double quotes, comma, semicolon, and backslash. :param expires: The maximum lifetime of the cookie as an HTTP-date timestamp. Provided datetime will be converted automatically. :param max_age: Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. If both Expires and Max-Age are set, Max-Age has precedence. :param domain: Hosts to where the cookie will be sent. If omitted, defaults to the host of the current document URL, not including subdomains. :param path: A path that must exist in the requested URL, or the browser won\u2019t send the Cookie header. :param samesite: Asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks. :param is_secure: A secure cookie is only sent to the server when a request is made with the https: scheme. :param is_httponly: Forbids JavaScript from accessing the cookie. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_cookie_name def get_cookie_name(self) -> str Extract the cookie name. Method get_cookie_value def get_cookie_value(self) -> str Extract the cookie value. Method get_expire def get_expire(self) -> Union[datetime.datetime, NoneType] Retrieve the parsed expiration date. Method get_max_age def get_max_age(self) -> Union[int, NoneType] Getting the max-age value as an integer if set. Method is_http_only def is_http_only(self) -> bool Determine if the cookie can only be accessed by the browser. Method is_secure def is_secure(self) -> bool Determine if the cookie is TLS/SSL only. Class StrictTransportSecurity class StrictTransportSecurity(max_age: int, does_includesubdomains: bool = False, is_preload: bool = False, **kwargs: Union[str, NoneType]) The HTTP Strict-Transport-Security response header (often abbreviated as HSTS) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP. :param max_age: The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS. :param does_includesubdomains: If this optional parameter is specified, this rule applies to all of the site\u2019s subdomains as well. :param is_preload: Preloading Strict Transport Security. Google maintains an HSTS preload service. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method does_includesubdomains def does_includesubdomains(self) -> bool Verify if this rule applies to all of the site\u2019s subdomains. Method get_max_age def get_max_age(self) -> Union[int, NoneType] Get the time, in seconds, if set, that the browser should remember. Method should_preload def should_preload(self) -> bool Verify if Preloading Strict Transport Security should be set. Class TransferEncoding class TransferEncoding(method: str, **kwargs: Union[str, NoneType]) The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user. :param method: Either chunked, compress, deflate, gzip, identity or br. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Descendants kiss_headers.builder.AcceptEncoding kiss_headers.builder.ContentEncoding Class UpgradeInsecureRequests class UpgradeInsecureRequests(**kwargs: Union[str, NoneType]) The HTTP Upgrade-Insecure-Requests request header sends a signal to the server expressing the client\u2019s preference for an encrypted and authenticated response, and that it can successfully handle the upgrade-insecure-requests CSP directive. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored. Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class UserAgent class UserAgent(characteristics: str, **kwargs: Union[str, NoneType]) The User-Agent request header is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting user agent. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored. Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class Vary class Vary(header_name: str, **kwargs: Union[str, NoneType]) The Vary HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. :param header_name: An header name to take into account when deciding whether or not a cached response can be used. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class WwwAuthenticate class WwwAuthenticate(auth_type: Union[str, NoneType] = None, challenge: str = 'realm', value: str = 'Secured area', **kwargs: Union[str, NoneType]) The HTTP WWW-Authenticate response header defines the authentication method that should be used to gain access to a resource. Fair-Warning : This header is like none other and is harder to parse. It need a specific case. www_authenticate = WwwAuthenticate ( \"Basic\" , \"realm\" , \"Secured area\" ) repr ( www_authenticate ) 'Www-Authenticate: Basic realm=\"Secured area\"' headers = www_authenticate + WwwAuthenticate ( challenge = \"charset\" , value = \"UTF-8\" ) repr ( headers ) 'Www-Authenticate: Basic realm=\"Secured area\", charset=\"UTF-8\"' www_authenticate . get_challenge () ( 'realm' , 'Secured area' ) www_authenticate . get_auth_type () 'Basic' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Methods Method get_auth_type def get_auth_type(self) -> Union[str, NoneType] Retrieve given authentication method if defined. Method get_challenge def get_challenge(self) -> Tuple[str, str] Output a tuple containing the challenge and the associated value. Raises :ValueError: Class XContentTypeOptions class XContentTypeOptions(nosniff: bool = True, **kwargs: Union[str, NoneType]) The X-Content-Type-Options response HTTP header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and be followed. This allows to opt-out of MIME type sniffing, or, in other words, it is a way to say that the webmasters knew what they were doing. :param nosniff: see https://fetch.spec.whatwg.org/#x-content-type-options-header :param kwargs: header = XContentTypeOptions ( nosniff = True ) repr ( header ) 'X-Content-Type-Options: nosniff' Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class XDnsPrefetchControl class XDnsPrefetchControl(enable: bool = True, **kwargs: Union[str, NoneType]) The X-DNS-Prefetch-Control HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth. :param enable: Toggle the specified behaviour. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class XFrameOptions class XFrameOptions(policy: str, **kwargs: Union[str, NoneType]) The X-Frame-Options HTTP response header can be used to indicate whether or not a browser should be allowed to render a page in a , , or . Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites. :param policy: Can be either DENY or SAMEORIGIN. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header Class XXssProtection class XXssProtection(enable_filtering: bool = True, enable_block_rendering: bool = False, report_uri: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The HTTP X-XSS-Protection response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (XSS) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong Content-Security-Policy that disables the use of inline JavaScript :param enable_filtering: Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts). :param enable_block_rendering: Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected. :param report_uri: (Chromium only) If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP report-uri directive to send a report. :param kwargs: Ancestors (in MRO) kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Custom Headers"},{"location":"APIs/custom-headers/#kiss_headers.builder","text":"","title":"Module kiss_headers.builder"},{"location":"APIs/custom-headers/#classes","text":"","title":"Classes"},{"location":"APIs/custom-headers/#kiss_headers.builder.Accept","text":"class Accept(mime: str = '*/*', qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. Using content negotiation, the server then selects one of the proposals, uses it and informs the client of its choice with the Content-Type response header. :param mime: Describe the MIME using this syntax :param qualifier: Any value used is placed in an order of preference expressed using relative quality value called the weight. :param kwargs: header = Accept ( \"text/html\" , qualifier = 0.8 ) header . content 'text/html; q=\"0.8\"' repr ( header ) 'Accept: text/html; q=\"0.8\"'","title":"Class Accept"},{"location":"APIs/custom-headers/#ancestors-in-mro","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.Accept.get_mime","text":"def get_mime(self) -> Union[str, NoneType] Return defined mime in current accept header.","title":"Method get_mime"},{"location":"APIs/custom-headers/#kiss_headers.builder.Accept.get_qualifier","text":"def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified mime. If not set, output 1.0.","title":"Method get_qualifier"},{"location":"APIs/custom-headers/#kiss_headers.builder.AcceptEncoding","text":"class AcceptEncoding(method: str, qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept-Encoding request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using content negotiation, the server selects one of the proposals, uses it and informs the client of its choice with the Content-Encoding response header. :param method: Either chunked, compress, deflate, gzip, identity, br or a wildcard. :param qualifier: Any value used is placed in an order of preference expressed using relative quality value called the weight. :param kwargs:","title":"Class AcceptEncoding"},{"location":"APIs/custom-headers/#ancestors-in-mro_1","text":"kiss_headers.builder.TransferEncoding kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_1","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.AcceptEncoding.get_qualifier","text":"def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified encoding. If not set, output 1.0.","title":"Method get_qualifier"},{"location":"APIs/custom-headers/#kiss_headers.builder.AcceptLanguage","text":"class AcceptLanguage(language: str = '*', qualifier: float = 1.0, **kwargs: Union[str, NoneType]) The Accept-Language request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) :param language: A language tag (which is sometimes referred to as a \u201clocale identifier\u201d). This consists of a 2-3 letter base language tag representing the language. :param qualifier: Any value placed in an order of preference expressed using a relative quality value called weight. :param kwargs:","title":"Class AcceptLanguage"},{"location":"APIs/custom-headers/#ancestors-in-mro_2","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_2","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.AcceptLanguage.get_qualifier","text":"def get_qualifier(self) -> Union[float, NoneType] Return defined qualifier for specified language. If not set, output 1.0.","title":"Method get_qualifier"},{"location":"APIs/custom-headers/#kiss_headers.builder.Allow","text":"class Allow(supported_verb: str, **kwargs: Union[str, NoneType]) The Allow header lists the set of methods supported by a resource. :param supported_verb: Choose exactly one of \u201cHEAD\u201d, \u201cGET\u201d, \u201cPOST\u201d, \u201cPUT\u201d, \u201cPATCH\u201d, \u201cDELETE\u201d, \u201cPURGE\u201d, \u201cCONNECT\u201d or \u201cTRACE\u201d HTTP verbs. :param kwargs: header = Allow ( \"POST\" ) repr ( header ) 'Allow: POST'","title":"Class Allow"},{"location":"APIs/custom-headers/#ancestors-in-mro_3","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc","text":"class AltSvc(protocol_id: str, alt_authority: str, max_age: Union[int, NoneType] = None, versions: Union[List[str], NoneType] = None, do_persist: Union[bool, NoneType] = None, **kwargs: Union[str, NoneType]) The Alt-Svc HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination. :param protocol_id: The ALPN protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol. :param alt_authority: The quoted string specifying the alternative authority which consists of an optional host override, a colon, and a mandatory port number. :param max_age: The number of seconds for which the alternative service is considered fresh. If omitted, it defaults to 24 hours. :param versions: List of supported versions of the protocol id if the protocol id can be ambiguous. (like QUIC) :param do_persist: Use the parameter to ensures that the entry is not deleted through network configuration changes. :param kwargs:","title":"Class AltSvc"},{"location":"APIs/custom-headers/#ancestors-in-mro_4","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_3","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc.get_alt_authority","text":"def get_alt_authority(self) -> str Extract the alternative authority which consists of an optional host override, a colon, and a mandatory port number.","title":"Method get_alt_authority"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc.get_max_age","text":"def get_max_age(self) -> Union[int, NoneType] Output the number of seconds for which the alternative service is considered fresh. None if undefined.","title":"Method get_max_age"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc.get_protocol_id","text":"def get_protocol_id(self) -> str Get the ALPN protocol identifier.","title":"Method get_protocol_id"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc.get_versions","text":"def get_versions(self) -> Union[List[str], NoneType] May return, if available, a list of versions of the ALPN protocol identifier.","title":"Method get_versions"},{"location":"APIs/custom-headers/#kiss_headers.builder.AltSvc.should_persist","text":"def should_persist(self) -> Union[bool, NoneType] Verify if the entry should not be deleted through network configuration changes. None if no indication.","title":"Method should_persist"},{"location":"APIs/custom-headers/#kiss_headers.builder.Authorization","text":"class Authorization(type_: str, credentials: str, **kwargs: Union[str, NoneType]) The HTTP Authorization request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a 401 Unauthorized status and the WWW-Authenticate header. :param type_: Authentication type. A common type is \u201cBasic\u201d. See IANA registry of Authentication schemes for others. :param credentials: Associated credentials to use. Preferably Base-64 encoded. header = Authorization ( \"Bearer\" , \"base64encoded\" ) repr ( header ) 'Authorization: Bearer base64encoded'","title":"Class Authorization"},{"location":"APIs/custom-headers/#ancestors-in-mro_5","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#descendants","text":"kiss_headers.builder.BasicAuthorization kiss_headers.builder.ProxyAuthorization","title":"Descendants"},{"location":"APIs/custom-headers/#methods_4","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.Authorization.get_auth_type","text":"def get_auth_type(self) -> str Return the auth type used in Authorization.","title":"Method get_auth_type"},{"location":"APIs/custom-headers/#kiss_headers.builder.Authorization.get_credentials","text":"def get_credentials(self) -> str Output the credentials.","title":"Method get_credentials"},{"location":"APIs/custom-headers/#kiss_headers.builder.BasicAuthorization","text":"class BasicAuthorization(username: str, password: str, charset: str = 'latin1', **kwargs: Union[str, NoneType]) Same as Authorization header but simplified for the Basic method. Also an example of override usage. :param username: :param password: :param charset: By default, credentials are encoded using latin1 charset. You may want to choose otherwise. :param kwargs: header = BasicAuthorization ( \"azerty\" , \"qwerty\" ) header Authorization : Basic YXplcnR5OnF3ZXJ0eQ == header . get_username_password () ( 'azerty' , 'qwerty' )","title":"Class BasicAuthorization"},{"location":"APIs/custom-headers/#ancestors-in-mro_6","text":"kiss_headers.builder.Authorization kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_5","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.BasicAuthorization.get_credentials","text":"def get_credentials(self) -> str Decode base64 encoded credentials from Authorization header.","title":"Method get_credentials"},{"location":"APIs/custom-headers/#kiss_headers.builder.BasicAuthorization.get_username_password","text":"def get_username_password(self) -> Tuple[str, ...] Extract username and password as a tuple from Basic Authorization.","title":"Method get_username_password"},{"location":"APIs/custom-headers/#kiss_headers.builder.CacheControl","text":"class CacheControl(directive: Union[str, NoneType] = None, max_age: Union[int, NoneType] = None, max_stale: Union[int, NoneType] = None, min_fresh: Union[int, NoneType] = None, s_maxage: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Cache-Control HTTP header holds directives (instructions) for caching in both requests and responses. A given directive in a request does not mean the same directive should be in the response. Pass only one parameter per CacheControl instance. :param directive: Could be one of must-revalidate, no-cache, no-store, no-transform, public, private, proxy-revalidate, only-if-cached, no-transform. :param max_age: The maximum amount of time a resource is considered fresh. Unlike Expires, this directive is relative to the time of the request. :param max_stale: Indicates the client will accept a stale response. An optional value in seconds indicates the upper limit of staleness the client will accept. :param min_fresh: Indicates the client wants a response that will still be fresh for at least the specified number of seconds. :param s_maxage: Overrides max-age or the Expires header, but only for shared caches (e.g., proxies). Ignored by private caches. :param kwargs:","title":"Class CacheControl"},{"location":"APIs/custom-headers/#ancestors-in-mro_7","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Connection","text":"class Connection(should_keep_alive: bool, **kwargs: Union[str, NoneType]) The Connection general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is keep-alive, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done. :param should_keep_alive: Indicates that the client would like to keep the connection open or not. :param kwargs:","title":"Class Connection"},{"location":"APIs/custom-headers/#ancestors-in-mro_8","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentDisposition","text":"class ContentDisposition(disposition: str = 'inline', name: Union[str, NoneType] = None, filename: Union[str, NoneType] = None, fallback_filename: Union[str, NoneType] = None, boundary: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) In a regular HTTP response, the Content-Disposition response header is a header indicating if the content is expected to be displayed inline in the browser, that is, as a Web page or as part of a Web page, or as an attachment, that is downloaded and saved locally. :param disposition: Could be either inline, form-data, attachment or empty. Choose one. Default to inline. :param name: Is a string containing the name of the HTML field in the form that the content of this subpart refers to. :param filename: Is a string containing the original name of the file transmitted. The filename is always optional and must not be used blindly by the application. ASCII-US Only. :param fallback_filename: Fallback filename if filename parameter does not uses the encoding defined in RFC 5987. :param boundary: For multipart entities the boundary directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. :param kwargs:","title":"Class ContentDisposition"},{"location":"APIs/custom-headers/#ancestors-in-mro_9","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentEncoding","text":"class ContentEncoding(method: str, **kwargs: Union[str, NoneType]) The Content-Encoding entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the Content-Type header. If multiple, keep them in the order in which they were applied. :param method: Either chunked, compress, deflate, gzip, identity or br. :param kwargs:","title":"Class ContentEncoding"},{"location":"APIs/custom-headers/#ancestors-in-mro_10","text":"kiss_headers.builder.TransferEncoding kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentLength","text":"class ContentLength(length: int, **kwargs: Union[str, NoneType]) The Content-Length entity header indicates the size of the entity-body, in bytes, sent to the recipient. :param length: The length in decimal number of octets.","title":"Class ContentLength"},{"location":"APIs/custom-headers/#ancestors-in-mro_11","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange","text":"class ContentRange(unit: str, start: int, end: int, size: Union[str, int], **kwargs: Union[str, NoneType]) The Content-Range response HTTP header indicates where in a full body message a partial message belongs. :param unit: The unit in which ranges is specified. This is usually bytes. :param start: An integer in the given unit indicating the beginning of the request range. :param end: An integer in the given unit indicating the end of the requested range. :param size: The total size of the document (or \u2018*\u2019 if unknown). :param kwargs: header = ContentRange ( \"bytes\" , 0 , 1024 , 4096 ) repr ( header ) 'Content-Range: bytes 0-1024/4096' header . get_size () 4096 header . unpack () ( 'bytes' , '0' , '1024' , '4096' )","title":"Class ContentRange"},{"location":"APIs/custom-headers/#ancestors-in-mro_12","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_6","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange.get_end","text":"def get_end(self) -> int Get the end of the requested range.","title":"Method get_end"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange.get_size","text":"def get_size(self) -> Union[str, int] Get the total size of the document (or \u2018*\u2019 if unknown).","title":"Method get_size"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange.get_start","text":"def get_start(self) -> int Get the beginning of the request range.","title":"Method get_start"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange.get_unit","text":"def get_unit(self) -> str Retrieve the unit in which ranges is specified.","title":"Method get_unit"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentRange.unpack","text":"def unpack(self) -> Tuple[str, str, str, str] Provide a basic way to parse ContentRange format.","title":"Method unpack"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentSecurityPolicy","text":"class ContentSecurityPolicy(*policies: List[str]) Content-Security-Policy is the name of a HTTP response header that modern browsers use to enhance the security of the document (or web page). The Content-Security-Policy header allows you to restrict how resources such as JavaScript, CSS, or pretty much anything that the browser loads. :param policies: One policy consist of a list of str like [\u201cdefault-src\u201d, \u201c\u2018none\u2019\u201c]. header = ContentSecurityPolicy ([ \"default-src\" , \"'none'\" ], [ \"img-src\" , \"'self'\" , \"img.example.com\" ]) repr ( header ) \"Content-Security-Policy: default-src 'none'; img-src 'self' img.example.com\" header . get_policies_names () [ 'default-src' , 'img-src' ] header . get_policy_args ( \"img-src\" ) [ \"'self'\" , 'img.example.com' ]","title":"Class ContentSecurityPolicy"},{"location":"APIs/custom-headers/#ancestors-in-mro_13","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_7","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentSecurityPolicy.get_policies_names","text":"def get_policies_names(self) -> List[str] Fetch a list of policy name set in content.","title":"Method get_policies_names"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentSecurityPolicy.get_policy_args","text":"def get_policy_args(self, policy_name: str) -> Union[List[str], NoneType] Retrieve given arguments for a policy.","title":"Method get_policy_args"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentType","text":"class ContentType(mime: str, charset: Union[str, NoneType] = None, format_: Union[str, NoneType] = None, boundary: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The Content-Type entity header is used to indicate the media type of the resource. In responses, a Content-Type header tells the client what the content type of the returned content actually is. Browsers will do MIME sniffing in some cases and will not necessarily follow the value of this header; to prevent this behavior, the header X-Content-Type-Options can be set to nosniff. :param mime_type: The MIME type of the resource or the data. Format / . :param charset: The character encoding standard. Should be an IANA name. :param format_: Mostly used in IMAP, could be one of : original or flowed. :param boundary: For multipart entities the boundary directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. :param kwargs: header = ContentType ( \"text/html\" , charset = \"utf-8\" ) repr ( header ) 'Content-Type: text/html; charset=\"UTF-8\"' header . get_charset () 'UTF-8' header . get_mime () 'text/html'","title":"Class ContentType"},{"location":"APIs/custom-headers/#ancestors-in-mro_14","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_8","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentType.get_charset","text":"def get_charset(self) -> Union[str, NoneType] Extract defined charset, if not present will return \u2018ISO-8859-1\u2019 by default.","title":"Method get_charset"},{"location":"APIs/custom-headers/#kiss_headers.builder.ContentType.get_mime","text":"def get_mime(self) -> Union[str, NoneType] Return defined mime in content type.","title":"Method get_mime"},{"location":"APIs/custom-headers/#kiss_headers.builder.Cookie","text":"class Cookie(**kwargs: Union[str, NoneType]) The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header. :param kwargs: Pair of cookie name associated with a value.","title":"Class Cookie"},{"location":"APIs/custom-headers/#ancestors-in-mro_15","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_9","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.Cookie.get_cookie_value","text":"def get_cookie_value(self, cookie_name: str) -> Union[str, NoneType] Retrieve associated value with a given cookie name.","title":"Method get_cookie_value"},{"location":"APIs/custom-headers/#kiss_headers.builder.Cookie.get_cookies_names","text":"def get_cookies_names(self) -> List[str] Retrieve all defined cookie names from Cookie header.","title":"Method get_cookies_names"},{"location":"APIs/custom-headers/#kiss_headers.builder.CrossOriginResourcePolicy","text":"class CrossOriginResourcePolicy(policy: str, **kwargs: Union[str, NoneType]) The HTTP Cross-Origin-Resource-Policy response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource. :param policy: Accepted values are same-site, same-origin or cross-origin. :param kwargs:","title":"Class CrossOriginResourcePolicy"},{"location":"APIs/custom-headers/#ancestors-in-mro_16","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.CustomHeader","text":"class CustomHeader(initial_content: str = '', **kwargs: Union[str, NoneType]) This class is a helper to create ready-to-use Header object with creation assistance. Should NOT be instantiated. Use this class as a direct parent for creating ready-to-use header object. Inspire yourself with already defined class bellow this one. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored.","title":"Class CustomHeader"},{"location":"APIs/custom-headers/#ancestors-in-mro_17","text":"kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#descendants_1","text":"kiss_headers.builder.Accept kiss_headers.builder.AcceptLanguage kiss_headers.builder.Allow kiss_headers.builder.AltSvc kiss_headers.builder.Authorization kiss_headers.builder.CacheControl kiss_headers.builder.Connection kiss_headers.builder.ContentDisposition kiss_headers.builder.ContentLength kiss_headers.builder.ContentRange kiss_headers.builder.ContentSecurityPolicy kiss_headers.builder.ContentType kiss_headers.builder.Cookie kiss_headers.builder.CrossOriginResourcePolicy kiss_headers.builder.Date kiss_headers.builder.Digest kiss_headers.builder.Dnt kiss_headers.builder.Etag kiss_headers.builder.Forwarded kiss_headers.builder.From kiss_headers.builder.Host kiss_headers.builder.IfMatch kiss_headers.builder.KeepAlive kiss_headers.builder.Location kiss_headers.builder.Referer kiss_headers.builder.ReferrerPolicy kiss_headers.builder.Server kiss_headers.builder.SetCookie kiss_headers.builder.StrictTransportSecurity kiss_headers.builder.TransferEncoding kiss_headers.builder.UpgradeInsecureRequests kiss_headers.builder.UserAgent kiss_headers.builder.Vary kiss_headers.builder.WwwAuthenticate kiss_headers.builder.XContentTypeOptions kiss_headers.builder.XDnsPrefetchControl kiss_headers.builder.XFrameOptions kiss_headers.builder.XXssProtection","title":"Descendants"},{"location":"APIs/custom-headers/#kiss_headers.builder.Date","text":"class Date(my_date: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Date general HTTP header contains the date and time at which the message was originated. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs:","title":"Class Date"},{"location":"APIs/custom-headers/#ancestors-in-mro_18","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#descendants_2","text":"kiss_headers.builder.Expires kiss_headers.builder.IfModifiedSince kiss_headers.builder.IfUnmodifiedSince kiss_headers.builder.LastModified kiss_headers.builder.RetryAfter","title":"Descendants"},{"location":"APIs/custom-headers/#methods_10","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.Date.get_datetime","text":"def get_datetime(self) -> datetime.datetime Parse and return a datetime according to content.","title":"Method get_datetime"},{"location":"APIs/custom-headers/#kiss_headers.builder.Digest","text":"class Digest(algorithm: str, value: str, **kwargs: Union[str, NoneType]) The Digest response HTTP header provides a digest of the requested resource. RFC 7231. :param algorithm: Supported digest algorithms are defined in RFC 3230 and RFC 5843, and include SHA-256 and SHA-512. :param value: The result of applying the digest algorithm to the resource representation and encoding the result. :param kwargs:","title":"Class Digest"},{"location":"APIs/custom-headers/#ancestors-in-mro_19","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Dnt","text":"class Dnt(tracking_consent: bool = False, **kwargs: Union[str, NoneType]) The DNT (Do Not Track) request header indicates the user\u2019s tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content. :param tracking_consent: The user prefers to allow tracking on the target site or not. :param kwargs:","title":"Class Dnt"},{"location":"APIs/custom-headers/#ancestors-in-mro_20","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Etag","text":"class Etag(etag_value: str, is_a_weak_validator: bool = False, **kwargs: Union[str, NoneType]) The ETag HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. :param etag_value: Entity tag uniquely representing the requested resource. ASCII string only. Not quoted. :param is_a_weak_validator: Indicates that a weak validator is used. Weak etags are easy to generate, but are far less useful for comparisons. :param kwargs:","title":"Class Etag"},{"location":"APIs/custom-headers/#ancestors-in-mro_21","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Expires","text":"class Expires(datetime_or_custom: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Expires header contains the date/time after which the response is considered stale. Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs:","title":"Class Expires"},{"location":"APIs/custom-headers/#ancestors-in-mro_22","text":"kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Forwarded","text":"class Forwarded(by: str, for_: str, using_proto: str, host: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The Forwarded header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request. :param by: The interface where the request came in to the proxy server. Could be an IP address, an obfuscated identifier or \u201cunknown\u201d. :param for_: The client that initiated the request and subsequent proxies in a chain of proxies. :param host: The Host request header field as received by the proxy. :param using_proto: Indicates which protocol was used to make the request (typically \u201chttp\u201d or \u201chttps\u201d). :param kwargs:","title":"Class Forwarded"},{"location":"APIs/custom-headers/#ancestors-in-mro_23","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.From","text":"class From(email: str, **kwargs: Union[str, NoneType]) The From request header contains an Internet email address for a human user who controls the requesting user agent. If you are running a robotic user agent (e.g. a crawler), the From header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests. :param email: A machine-usable email address. See RFC 5322. :param kwargs:","title":"Class From"},{"location":"APIs/custom-headers/#ancestors-in-mro_24","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Host","text":"class Host(host: str, port: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Host request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening. :param host: The domain name of the server (for virtual hosting). :param port: TCP port number on which the server is listening. header = Host ( \"www.python.org\" ) repr ( header ) 'Host: www.python.org' header = Host ( \"www.python.org\" , port = 8000 ) repr ( header ) 'Host: www.python.org:8000'","title":"Class Host"},{"location":"APIs/custom-headers/#ancestors-in-mro_25","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.IfMatch","text":"class IfMatch(etag_value: str, **kwargs: Union[str, NoneType]) The If-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case. :param etag_value: Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like \u201c675af34563dc-tr34\u201d). :param kwargs:","title":"Class IfMatch"},{"location":"APIs/custom-headers/#ancestors-in-mro_26","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#descendants_3","text":"kiss_headers.builder.IfNoneMatch","title":"Descendants"},{"location":"APIs/custom-headers/#kiss_headers.builder.IfModifiedSince","text":"class IfModifiedSince(dt: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The If-Modified-Since request HTTP header makes the request conditional :param dt: :param kwargs:","title":"Class IfModifiedSince"},{"location":"APIs/custom-headers/#ancestors-in-mro_27","text":"kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.IfNoneMatch","text":"class IfNoneMatch(etag_value: str, **kwargs: Union[str, NoneType]) The If-None-Match HTTP request header makes the request conditional. For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if it doesn\u2019t have an ETag matching the given ones. For other methods, the request will be processed only if the eventually existing resource\u2019s ETag doesn\u2019t match any of the values listed. :param etag_value: Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like \u201c675af34563dc-tr34\u201d). :param kwargs:","title":"Class IfNoneMatch"},{"location":"APIs/custom-headers/#ancestors-in-mro_28","text":"kiss_headers.builder.IfMatch kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.IfUnmodifiedSince","text":"class IfUnmodifiedSince(dt: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The If-Unmodified-Since request HTTP header makes the request conditional :param dt: :param kwargs:","title":"Class IfUnmodifiedSince"},{"location":"APIs/custom-headers/#ancestors-in-mro_29","text":"kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.KeepAlive","text":"class KeepAlive(timeout: Union[int, NoneType] = None, max_: Union[int, NoneType] = None, **kwargs: Union[str, NoneType]) The Keep-Alive general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests. :param timeout: indicating the minimum amount of time an idle connection has to be kept opened (in seconds). :param max: indicating the maximum number of requests that can be sent on this connection before closing it. :param kwargs:","title":"Class KeepAlive"},{"location":"APIs/custom-headers/#ancestors-in-mro_30","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.LastModified","text":"class LastModified(my_date: Union[datetime.datetime, str], **kwargs: Union[str, NoneType]) The Last-Modified response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. :param my_date: :param kwargs:","title":"Class LastModified"},{"location":"APIs/custom-headers/#ancestors-in-mro_31","text":"kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Location","text":"class Location(uri: str, **kwargs: Union[str, NoneType]) The Location response header indicates the URL to redirect a page to. It only provides a meaning when served with a 3xx (redirection) or 201 (created) status response. :param uri: A relative (to the request URL) or absolute URL. :param kwargs:","title":"Class Location"},{"location":"APIs/custom-headers/#ancestors-in-mro_32","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ProxyAuthorization","text":"class ProxyAuthorization(type_: str, credentials: str) The HTTP Proxy-Authorization request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a 407 Proxy Authentication Required status and the Proxy-Authenticate header. :param type_: Authentication type. A common type is \u201cBasic\u201d. See IANA registry of Authentication schemes for others. :param credentials: Associated credentials to use. Preferably Base-64 encoded.","title":"Class ProxyAuthorization"},{"location":"APIs/custom-headers/#ancestors-in-mro_33","text":"kiss_headers.builder.Authorization kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Referer","text":"class Referer(url: str, **kwargs: Union[str, NoneType]) The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example. Note that referer is actually a misspelling of the word \u201creferrer\u201d. See https://en.wikipedia.org/wiki/HTTP_referer :param url: An absolute or partial address of the previous web page from which a link to the currently requested page was followed. URL fragments not included. :param kwargs:","title":"Class Referer"},{"location":"APIs/custom-headers/#ancestors-in-mro_34","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.ReferrerPolicy","text":"class ReferrerPolicy(policy: str, **kwargs: Union[str, NoneType]) The Referrer-Policy HTTP header controls how much referrer information (sent via the Referer header) should be included with requests. :param policy: Either \u201cno-referrer\u201d, \u201cno-referrer-when-downgrade\u201d, \u201corigin\u201d, \u201corigin-when-cross-origin\u201d, \u201csame-origin\u201d, \u201cstrict-origin\u201d, \u201cstrict-origin-when-cross-origin\u201d, \u201cunsafe-url\u201d :param kwargs:","title":"Class ReferrerPolicy"},{"location":"APIs/custom-headers/#ancestors-in-mro_35","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.RetryAfter","text":"class RetryAfter(delay_or_date: Union[datetime.datetime, int], **kwargs: Union[str, NoneType]) The Retry-After response HTTP header indicates how long the user agent should wait before making a follow-up request. :param my_date: Can either be a datetime that will be automatically converted or a raw string. :param kwargs:","title":"Class RetryAfter"},{"location":"APIs/custom-headers/#ancestors-in-mro_36","text":"kiss_headers.builder.Date kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Server","text":"class Server(product: str, **kwargs: Union[str, NoneType]) The Server header describes the software used by the origin server that handled the request \u2014 that is, the server that generated the response. :param product: The name of the software or product that handled the request. Usually in a format similar to User-Agent. :param kwargs:","title":"Class Server"},{"location":"APIs/custom-headers/#ancestors-in-mro_37","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie","text":"class SetCookie(cookie_name: str, cookie_value: str, expires: Union[datetime.datetime, str, NoneType] = None, max_age: Union[int, NoneType] = None, domain: Union[str, NoneType] = None, path: Union[str, NoneType] = None, samesite: Union[str, NoneType] = None, is_secure: bool = False, is_httponly: bool = True, **kwargs: Union[str, NoneType]) The Set-Cookie HTTP response header is used to send cookies from the server to the user agent, so the user agent can send them back to the server later. :param cookie_name: Can be any US-ASCII characters, except control characters, spaces, or tabs. :param cookie_value: Can include any US-ASCII characters excluding control characters, Whitespace, double quotes, comma, semicolon, and backslash. :param expires: The maximum lifetime of the cookie as an HTTP-date timestamp. Provided datetime will be converted automatically. :param max_age: Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. If both Expires and Max-Age are set, Max-Age has precedence. :param domain: Hosts to where the cookie will be sent. If omitted, defaults to the host of the current document URL, not including subdomains. :param path: A path that must exist in the requested URL, or the browser won\u2019t send the Cookie header. :param samesite: Asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks. :param is_secure: A secure cookie is only sent to the server when a request is made with the https: scheme. :param is_httponly: Forbids JavaScript from accessing the cookie. :param kwargs:","title":"Class SetCookie"},{"location":"APIs/custom-headers/#ancestors-in-mro_38","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_11","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.get_cookie_name","text":"def get_cookie_name(self) -> str Extract the cookie name.","title":"Method get_cookie_name"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.get_cookie_value","text":"def get_cookie_value(self) -> str Extract the cookie value.","title":"Method get_cookie_value"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.get_expire","text":"def get_expire(self) -> Union[datetime.datetime, NoneType] Retrieve the parsed expiration date.","title":"Method get_expire"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.get_max_age","text":"def get_max_age(self) -> Union[int, NoneType] Getting the max-age value as an integer if set.","title":"Method get_max_age"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.is_http_only","text":"def is_http_only(self) -> bool Determine if the cookie can only be accessed by the browser.","title":"Method is_http_only"},{"location":"APIs/custom-headers/#kiss_headers.builder.SetCookie.is_secure","text":"def is_secure(self) -> bool Determine if the cookie is TLS/SSL only.","title":"Method is_secure"},{"location":"APIs/custom-headers/#kiss_headers.builder.StrictTransportSecurity","text":"class StrictTransportSecurity(max_age: int, does_includesubdomains: bool = False, is_preload: bool = False, **kwargs: Union[str, NoneType]) The HTTP Strict-Transport-Security response header (often abbreviated as HSTS) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP. :param max_age: The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS. :param does_includesubdomains: If this optional parameter is specified, this rule applies to all of the site\u2019s subdomains as well. :param is_preload: Preloading Strict Transport Security. Google maintains an HSTS preload service. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. :param kwargs:","title":"Class StrictTransportSecurity"},{"location":"APIs/custom-headers/#ancestors-in-mro_39","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_12","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.StrictTransportSecurity.does_includesubdomains","text":"def does_includesubdomains(self) -> bool Verify if this rule applies to all of the site\u2019s subdomains.","title":"Method does_includesubdomains"},{"location":"APIs/custom-headers/#kiss_headers.builder.StrictTransportSecurity.get_max_age","text":"def get_max_age(self) -> Union[int, NoneType] Get the time, in seconds, if set, that the browser should remember.","title":"Method get_max_age"},{"location":"APIs/custom-headers/#kiss_headers.builder.StrictTransportSecurity.should_preload","text":"def should_preload(self) -> bool Verify if Preloading Strict Transport Security should be set.","title":"Method should_preload"},{"location":"APIs/custom-headers/#kiss_headers.builder.TransferEncoding","text":"class TransferEncoding(method: str, **kwargs: Union[str, NoneType]) The Transfer-Encoding header specifies the form of encoding used to safely transfer the payload body to the user. :param method: Either chunked, compress, deflate, gzip, identity or br. :param kwargs:","title":"Class TransferEncoding"},{"location":"APIs/custom-headers/#ancestors-in-mro_40","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#descendants_4","text":"kiss_headers.builder.AcceptEncoding kiss_headers.builder.ContentEncoding","title":"Descendants"},{"location":"APIs/custom-headers/#kiss_headers.builder.UpgradeInsecureRequests","text":"class UpgradeInsecureRequests(**kwargs: Union[str, NoneType]) The HTTP Upgrade-Insecure-Requests request header sends a signal to the server expressing the client\u2019s preference for an encrypted and authenticated response, and that it can successfully handle the upgrade-insecure-requests CSP directive. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored.","title":"Class UpgradeInsecureRequests"},{"location":"APIs/custom-headers/#ancestors-in-mro_41","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.UserAgent","text":"class UserAgent(characteristics: str, **kwargs: Union[str, NoneType]) The User-Agent request header is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting user agent. :param initial_content: Initial content of the Header if any. :param kwargs: Provided args. Any key that associate a None value are just ignored.","title":"Class UserAgent"},{"location":"APIs/custom-headers/#ancestors-in-mro_42","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.Vary","text":"class Vary(header_name: str, **kwargs: Union[str, NoneType]) The Vary HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. :param header_name: An header name to take into account when deciding whether or not a cached response can be used. :param kwargs:","title":"Class Vary"},{"location":"APIs/custom-headers/#ancestors-in-mro_43","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.WwwAuthenticate","text":"class WwwAuthenticate(auth_type: Union[str, NoneType] = None, challenge: str = 'realm', value: str = 'Secured area', **kwargs: Union[str, NoneType]) The HTTP WWW-Authenticate response header defines the authentication method that should be used to gain access to a resource. Fair-Warning : This header is like none other and is harder to parse. It need a specific case. www_authenticate = WwwAuthenticate ( \"Basic\" , \"realm\" , \"Secured area\" ) repr ( www_authenticate ) 'Www-Authenticate: Basic realm=\"Secured area\"' headers = www_authenticate + WwwAuthenticate ( challenge = \"charset\" , value = \"UTF-8\" ) repr ( headers ) 'Www-Authenticate: Basic realm=\"Secured area\", charset=\"UTF-8\"' www_authenticate . get_challenge () ( 'realm' , 'Secured area' ) www_authenticate . get_auth_type () 'Basic'","title":"Class WwwAuthenticate"},{"location":"APIs/custom-headers/#ancestors-in-mro_44","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#methods_13","text":"","title":"Methods"},{"location":"APIs/custom-headers/#kiss_headers.builder.WwwAuthenticate.get_auth_type","text":"def get_auth_type(self) -> Union[str, NoneType] Retrieve given authentication method if defined.","title":"Method get_auth_type"},{"location":"APIs/custom-headers/#kiss_headers.builder.WwwAuthenticate.get_challenge","text":"def get_challenge(self) -> Tuple[str, str] Output a tuple containing the challenge and the associated value. Raises :ValueError:","title":"Method get_challenge"},{"location":"APIs/custom-headers/#kiss_headers.builder.XContentTypeOptions","text":"class XContentTypeOptions(nosniff: bool = True, **kwargs: Union[str, NoneType]) The X-Content-Type-Options response HTTP header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and be followed. This allows to opt-out of MIME type sniffing, or, in other words, it is a way to say that the webmasters knew what they were doing. :param nosniff: see https://fetch.spec.whatwg.org/#x-content-type-options-header :param kwargs: header = XContentTypeOptions ( nosniff = True ) repr ( header ) 'X-Content-Type-Options: nosniff'","title":"Class XContentTypeOptions"},{"location":"APIs/custom-headers/#ancestors-in-mro_45","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.XDnsPrefetchControl","text":"class XDnsPrefetchControl(enable: bool = True, **kwargs: Union[str, NoneType]) The X-DNS-Prefetch-Control HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth. :param enable: Toggle the specified behaviour. :param kwargs:","title":"Class XDnsPrefetchControl"},{"location":"APIs/custom-headers/#ancestors-in-mro_46","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.XFrameOptions","text":"class XFrameOptions(policy: str, **kwargs: Union[str, NoneType]) The X-Frame-Options HTTP response header can be used to indicate whether or not a browser should be allowed to render a page in a , , or . Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites. :param policy: Can be either DENY or SAMEORIGIN. :param kwargs:","title":"Class XFrameOptions"},{"location":"APIs/custom-headers/#ancestors-in-mro_47","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/custom-headers/#kiss_headers.builder.XXssProtection","text":"class XXssProtection(enable_filtering: bool = True, enable_block_rendering: bool = False, report_uri: Union[str, NoneType] = None, **kwargs: Union[str, NoneType]) The HTTP X-XSS-Protection response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (XSS) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong Content-Security-Policy that disables the use of inline JavaScript :param enable_filtering: Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts). :param enable_block_rendering: Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected. :param report_uri: (Chromium only) If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP report-uri directive to send a report. :param kwargs:","title":"Class XXssProtection"},{"location":"APIs/custom-headers/#ancestors-in-mro_48","text":"kiss_headers.builder.CustomHeader kiss_headers.models.Header","title":"Ancestors (in MRO)"},{"location":"APIs/functions/","text":"Module kiss_headers.api Functions Function explain def explain(headers: kiss_headers.models.Headers) -> kiss_headers.structures.CaseInsensitiveDict Return a brief explanation of each header present in headers if available. Function get_polymorphic def get_polymorphic(target: Union[kiss_headers.models.Headers, kiss_headers.models.Header], desired_output: Type[~T]) -> Union[~T, List[~T], NoneType] Experimental. Transform an Header or Headers object to its target CustomHeader subclass in order to access more ready-to-use methods. eg. You have an Header object named \u2018Set-Cookie\u2019 and you wish to extract the expiration date as a datetime. header = Header ( \"Set-Cookie\" , \"1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT\" ) header [ \"expires\" ] 'Wed, 15-Apr-2020 21:27:31 GMT' from kiss_headers import SetCookie set_cookie = get_polymorphic ( header , SetCookie ) set_cookie . get_expire () datetime . datetime ( 2020 , 4 , 15 , 21 , 27 , 31 , tzinfo = datetime . timezone . utc ) Function parse_it def parse_it(raw_headers: Any) -> kiss_headers.models.Headers Just decode anything that could contain headers. That simple PERIOD. :param raw_headers: Accept bytes, str, fp, dict, email.Message, requests.Response, urllib3.HTTPResponse and httpx.Response. :raises: TypeError: If passed argument cannot be parsed to extract headers from it.","title":"API"},{"location":"APIs/functions/#kiss_headers.api","text":"","title":"Module kiss_headers.api"},{"location":"APIs/functions/#functions","text":"","title":"Functions"},{"location":"APIs/functions/#kiss_headers.api.explain","text":"def explain(headers: kiss_headers.models.Headers) -> kiss_headers.structures.CaseInsensitiveDict Return a brief explanation of each header present in headers if available.","title":"Function explain"},{"location":"APIs/functions/#kiss_headers.api.get_polymorphic","text":"def get_polymorphic(target: Union[kiss_headers.models.Headers, kiss_headers.models.Header], desired_output: Type[~T]) -> Union[~T, List[~T], NoneType] Experimental. Transform an Header or Headers object to its target CustomHeader subclass in order to access more ready-to-use methods. eg. You have an Header object named \u2018Set-Cookie\u2019 and you wish to extract the expiration date as a datetime. header = Header ( \"Set-Cookie\" , \"1P_JAR=2020-03-16-21; expires=Wed, 15-Apr-2020 21:27:31 GMT\" ) header [ \"expires\" ] 'Wed, 15-Apr-2020 21:27:31 GMT' from kiss_headers import SetCookie set_cookie = get_polymorphic ( header , SetCookie ) set_cookie . get_expire () datetime . datetime ( 2020 , 4 , 15 , 21 , 27 , 31 , tzinfo = datetime . timezone . utc )","title":"Function get_polymorphic"},{"location":"APIs/functions/#kiss_headers.api.parse_it","text":"def parse_it(raw_headers: Any) -> kiss_headers.models.Headers Just decode anything that could contain headers. That simple PERIOD. :param raw_headers: Accept bytes, str, fp, dict, email.Message, requests.Response, urllib3.HTTPResponse and httpx.Response. :raises: TypeError: If passed argument cannot be parsed to extract headers from it.","title":"Function parse_it"},{"location":"APIs/models/","text":"Module kiss_headers.models Functions Function lock_output_type def lock_output_type(lock: bool = True) -> NoneType This method will restrict type entropy by always returning a List[Header] instead of Union[Header, List[Header]] Classes Class Header class Header(name: str, content: str) Object representation of a single Header. :param name: The name of the header, should contain only ASCII characters with no spaces in it. :param content: Initial content associated with the header. Descendants kiss_headers.builder.CustomHeader Instance variables Variable attrs List of members or attributes found in provided content. eg. Content-Type: application/json; charset=utf-8; format=origin Would output : [\u2018application/json\u2019, \u2018charset\u2019, \u2018format\u2019] Variable comments Retrieve comments in header content. Variable content Output associated content to header as it was captured initially. header = Header ( \"ETag\" , '\"33a64df551425fcc55e4d42a148795d9f25f89d4\"' ) header . content '33a64df551425fcc55e4d42a148795d9f25f89d4' Variable name Output the original header name as it was captured initially Variable normalized_name Output header name but normalized, lower case and \u2018-\u2018 character become \u2018_\u2019. Variable pretty_name Output a prettified name of the header. First letter capitalized of each word. Variable unfolded_content Output unfolded associated content to header. Meaning that every LF + n space(s) would be properly replaced. Methods Method get def get(self, attr: str) -> Union[str, List[str], NoneType] Retrieve associated value of an attribute. header = Header ( \"Content-Type\" , \"application/json; charset=UTF-8; format=flowed\" ) header . charset 'UTF-8' header . ChArSeT 'UTF-8' header . FORMAT 'flowed' header . format 'flowed' Method has def has(self, attr: str) -> bool Safely check is current header has an attribute or adjective in it. Method has_many def has_many(self, name: str) -> bool Determine if an attribute name has multiple entries in Header. Detect OneToMany entries. header = Header ( \"A\" , \"charset=UTF-8; charset=ASCII; format=flowed\" ) header . has_many ( \"charset\" ) True header . has_many ( \"format\" ) False Class Headers class Headers(*headers: Union[List[kiss_headers.models.Header], kiss_headers.models.Header]) Object oriented representation for Headers. Contains a list of Header with some level of abstraction. Combine advantages of dict, CaseInsensibleDict and native objects. Headers does not inherit of the Mapping type, but it does borrow some concept from it. :param headers: Initial list of header. Can be empty. Methods Method get def get(self, header: str) -> Union[kiss_headers.models.Header, List[kiss_headers.models.Header], NoneType] Retrieve header from headers if exists Method has def has(self, header: str) -> bool Safely check if header name is in headers Method has_many def has_many(self, name: str) -> bool Determine if an header name has multiple entries in Headers. Detect OneToMany entries. headers = Header ( \"A\" , \"0\" ) + Header ( \"A\" , \"1\" ) + Header ( \"B\" , \"sad\" ) headers . has_many ( \"a\" ) True headers . has_many ( \"b\" ) False Method items def items(self) -> List[Tuple[str, str]] Provide an iterator witch each entry contain a tuple of header name and content. This wont return a ItemView. headers = Header ( \"X-Hello-World\" , \"1\" ) + Header ( \"Content-Type\" , \"happiness=True\" ) + Header ( \"Content-Type\" , \"happiness=False\" ) headers . items () [( 'X-Hello-World' , '1' ), ( 'Content-Type' , 'happiness=True' ), ( 'Content-Type' , 'happiness=False' )] Method keys def keys(self) -> List[str] Return a list of distinct header name set in headers. Be aware that it wont return a typing.KeysView Method pop def pop(self) -> Union[kiss_headers.models.Header, List[kiss_headers.models.Header]] Pop header from headers. By default the last one. Method popitem def popitem(self) -> Tuple[str, str] Pop last header as a tuple (header name, header content). Method to_dict def to_dict(self) -> kiss_headers.structures.CaseInsensitiveDict Provide a CaseInsensitiveDict output of current headers. This output type has been borrowed from psf/requests. If one header appear multiple times, if would be concatenated into the same value, separated by comma. Be aware that this repr could lead to mistake. Method to_json def to_json(self) -> str Provide a JSON representation of Headers Method values def values(self) -> NotImplemented I choose not to implement values() on Headers as it would bring more confusion.. Either we make it the same len as keys() or we don\u2019t. Either way don\u2019t please me. Hope to ear from the community about this.","title":"Models"},{"location":"APIs/models/#kiss_headers.models","text":"","title":"Module kiss_headers.models"},{"location":"APIs/models/#functions","text":"","title":"Functions"},{"location":"APIs/models/#kiss_headers.models.lock_output_type","text":"def lock_output_type(lock: bool = True) -> NoneType This method will restrict type entropy by always returning a List[Header] instead of Union[Header, List[Header]]","title":"Function lock_output_type"},{"location":"APIs/models/#classes","text":"","title":"Classes"},{"location":"APIs/models/#kiss_headers.models.Header","text":"class Header(name: str, content: str) Object representation of a single Header. :param name: The name of the header, should contain only ASCII characters with no spaces in it. :param content: Initial content associated with the header.","title":"Class Header"},{"location":"APIs/models/#descendants","text":"kiss_headers.builder.CustomHeader","title":"Descendants"},{"location":"APIs/models/#instance-variables","text":"","title":"Instance variables"},{"location":"APIs/models/#kiss_headers.models.Header.attrs","text":"List of members or attributes found in provided content. eg. Content-Type: application/json; charset=utf-8; format=origin Would output : [\u2018application/json\u2019, \u2018charset\u2019, \u2018format\u2019]","title":"Variable attrs"},{"location":"APIs/models/#kiss_headers.models.Header.comments","text":"Retrieve comments in header content.","title":"Variable comments"},{"location":"APIs/models/#kiss_headers.models.Header.content","text":"Output associated content to header as it was captured initially. header = Header ( \"ETag\" , '\"33a64df551425fcc55e4d42a148795d9f25f89d4\"' ) header . content '33a64df551425fcc55e4d42a148795d9f25f89d4'","title":"Variable content"},{"location":"APIs/models/#kiss_headers.models.Header.name","text":"Output the original header name as it was captured initially","title":"Variable name"},{"location":"APIs/models/#kiss_headers.models.Header.normalized_name","text":"Output header name but normalized, lower case and \u2018-\u2018 character become \u2018_\u2019.","title":"Variable normalized_name"},{"location":"APIs/models/#kiss_headers.models.Header.pretty_name","text":"Output a prettified name of the header. First letter capitalized of each word.","title":"Variable pretty_name"},{"location":"APIs/models/#kiss_headers.models.Header.unfolded_content","text":"Output unfolded associated content to header. Meaning that every LF + n space(s) would be properly replaced.","title":"Variable unfolded_content"},{"location":"APIs/models/#methods","text":"","title":"Methods"},{"location":"APIs/models/#kiss_headers.models.Header.get","text":"def get(self, attr: str) -> Union[str, List[str], NoneType] Retrieve associated value of an attribute. header = Header ( \"Content-Type\" , \"application/json; charset=UTF-8; format=flowed\" ) header . charset 'UTF-8' header . ChArSeT 'UTF-8' header . FORMAT 'flowed' header . format 'flowed'","title":"Method get"},{"location":"APIs/models/#kiss_headers.models.Header.has","text":"def has(self, attr: str) -> bool Safely check is current header has an attribute or adjective in it.","title":"Method has"},{"location":"APIs/models/#kiss_headers.models.Header.has_many","text":"def has_many(self, name: str) -> bool Determine if an attribute name has multiple entries in Header. Detect OneToMany entries. header = Header ( \"A\" , \"charset=UTF-8; charset=ASCII; format=flowed\" ) header . has_many ( \"charset\" ) True header . has_many ( \"format\" ) False","title":"Method has_many"},{"location":"APIs/models/#kiss_headers.models.Headers","text":"class Headers(*headers: Union[List[kiss_headers.models.Header], kiss_headers.models.Header]) Object oriented representation for Headers. Contains a list of Header with some level of abstraction. Combine advantages of dict, CaseInsensibleDict and native objects. Headers does not inherit of the Mapping type, but it does borrow some concept from it. :param headers: Initial list of header. Can be empty.","title":"Class Headers"},{"location":"APIs/models/#methods_1","text":"","title":"Methods"},{"location":"APIs/models/#kiss_headers.models.Headers.get","text":"def get(self, header: str) -> Union[kiss_headers.models.Header, List[kiss_headers.models.Header], NoneType] Retrieve header from headers if exists","title":"Method get"},{"location":"APIs/models/#kiss_headers.models.Headers.has","text":"def has(self, header: str) -> bool Safely check if header name is in headers","title":"Method has"},{"location":"APIs/models/#kiss_headers.models.Headers.has_many","text":"def has_many(self, name: str) -> bool Determine if an header name has multiple entries in Headers. Detect OneToMany entries. headers = Header ( \"A\" , \"0\" ) + Header ( \"A\" , \"1\" ) + Header ( \"B\" , \"sad\" ) headers . has_many ( \"a\" ) True headers . has_many ( \"b\" ) False","title":"Method has_many"},{"location":"APIs/models/#kiss_headers.models.Headers.items","text":"def items(self) -> List[Tuple[str, str]] Provide an iterator witch each entry contain a tuple of header name and content. This wont return a ItemView. headers = Header ( \"X-Hello-World\" , \"1\" ) + Header ( \"Content-Type\" , \"happiness=True\" ) + Header ( \"Content-Type\" , \"happiness=False\" ) headers . items () [( 'X-Hello-World' , '1' ), ( 'Content-Type' , 'happiness=True' ), ( 'Content-Type' , 'happiness=False' )]","title":"Method items"},{"location":"APIs/models/#kiss_headers.models.Headers.keys","text":"def keys(self) -> List[str] Return a list of distinct header name set in headers. Be aware that it wont return a typing.KeysView","title":"Method keys"},{"location":"APIs/models/#kiss_headers.models.Headers.pop","text":"def pop(self) -> Union[kiss_headers.models.Header, List[kiss_headers.models.Header]] Pop header from headers. By default the last one.","title":"Method pop"},{"location":"APIs/models/#kiss_headers.models.Headers.popitem","text":"def popitem(self) -> Tuple[str, str] Pop last header as a tuple (header name, header content).","title":"Method popitem"},{"location":"APIs/models/#kiss_headers.models.Headers.to_dict","text":"def to_dict(self) -> kiss_headers.structures.CaseInsensitiveDict Provide a CaseInsensitiveDict output of current headers. This output type has been borrowed from psf/requests. If one header appear multiple times, if would be concatenated into the same value, separated by comma. Be aware that this repr could lead to mistake.","title":"Method to_dict"},{"location":"APIs/models/#kiss_headers.models.Headers.to_json","text":"def to_json(self) -> str Provide a JSON representation of Headers","title":"Method to_json"},{"location":"APIs/models/#kiss_headers.models.Headers.values","text":"def values(self) -> NotImplemented I choose not to implement values() on Headers as it would bring more confusion.. Either we make it the same len as keys() or we don\u2019t. Either way don\u2019t please me. Hope to ear from the community about this.","title":"Method values"},{"location":"APIs/others/","text":"Module kiss_headers.utils Functions Function class_to_header_name def class_to_header_name(type_: Type) -> str Take a type and infer its header name. from kiss_headers.builder import ContentType , XContentTypeOptions , BasicAuthorization class_to_header_name ( ContentType ) 'Content-Type' class_to_header_name ( XContentTypeOptions ) 'X-Content-Type-Options' class_to_header_name ( BasicAuthorization ) 'Authorization' Function count_leftover_space def count_leftover_space(content: str) -> int Recursive function that count trailing white space at the end of given string. count_leftover_space ( \"hello \" ) 3 count_leftover_space ( \"byebye \" ) 1 count_leftover_space ( \" hello \" ) 1 count_leftover_space ( \" hello \" ) 4 Function decode_partials def decode_partials(items: Iterable[Tuple[str, Any]]) -> List[Tuple[str, str]] This function takes a list of tuple, representing headers by key, value. Where value is bytes or string containing (RFC 2047 encoded) partials fragments like the following : decode_partials ([( \"Subject\" , \"=?iso-8859-1?q?p=F6stal?=\" )]) [( 'Subject' , 'p\u00f6stal' )] Function extract_class_name def extract_class_name(type_: Type) -> Union[str, NoneType] Typically extract a class name from a Type. Function extract_comments def extract_comments(content: str) -> List[str] Extract parts of content that are considered as comments. Between parenthesis. extract_comments ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 (hello) llll (abc)\" ) [ 'Macintosh; Intel Mac OS X 10.9; rv:50.0' , 'hello' , 'abc' ] Function extract_encoded_headers def extract_encoded_headers(payload: bytes) -> Tuple[str, bytes] This function purpose is to extract lines that can be decoded using utf-8. extract_encoded_headers ( \"Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n\\r\\n \" . encode ( \"utf-8\" )) ( 'Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n ' , b '' ) extract_encoded_headers ( \"Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n\\r\\n That IS totally random.\" . encode ( \"utf-8\" )) ( 'Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n ' , b 'That IS totally random.' ) Function header_content_split def header_content_split(string: str, delimiter: str) -> List[str] Take a string and split it according to the passed delimiter. It will ignore delimiter if inside between double quote, inside a value or in parenthesis. The input string is considered perfectly formed. This function do not split coma on a day when attached, see \u201cRFC 7231, section 7.1.1.2: Date\u201d. header_content_split ( \"Wed, 15-Apr-2020 21:27:31 GMT, Fri, 01-Jan-2038 00:00:00 GMT\" , \",\" ) [ 'Wed, 15-Apr-2020 21:27:31 GMT' , 'Fri, 01-Jan-2038 00:00:00 GMT' ] header_content_split ( 'quic=\":443\"; ma=2592000; v=\"46,43\", h3-Q050=\":443\"; ma=2592000, h3-Q049=\":443\"; ma=2592000' , \",\" ) [ 'quic=\":443\"; ma=2592000; v=\"46,43\"' , 'h3-Q050=\":443\"; ma=2592000' , 'h3-Q049=\":443\"; ma=2592000' ] header_content_split ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\" , \";\" ) [ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0' ] header_content_split ( \"text/html; charset=UTF-8\" , \";\" ) [ 'text/html' , 'charset=UTF-8' ] Function header_name_to_class def header_name_to_class(name: str, root_type: Type) -> Type The opposite of class_to_header_name function. Will raise TypeError if no corresponding entry is found. Do it recursively from the root type. from kiss_headers.builder import CustomHeader , ContentType , XContentTypeOptions , LastModified , Date header_name_to_class ( \"Content-Type\" , CustomHeader ) < class ' kiss_headers . builder . ContentType '> header_name_to_class ( \"Last-Modified\" , CustomHeader ) < class ' kiss_headers . builder . LastModified '> Function header_strip def header_strip(content: str, elem: str) -> str Remove a member for a given header content and take care of the unneeded leftover semi-colon. header_strip ( \"text/html; charset=UTF-8; format=flowed\" , \"charset=UTF-8\" ) 'text/html; format=flowed' header_strip ( \"text/html; charset=UTF-8; format=flowed\" , \"charset=UTF-8\" ) 'text/html; format=flowed' Function is_legal_header_name def is_legal_header_name(name: str) -> bool Verify if a provided header name is valid. is_legal_header_name ( \":hello\" ) False is_legal_header_name ( \"hello\" ) True is_legal_header_name ( \"Content-Type\" ) True is_legal_header_name ( \"Hello;\" ) False is_legal_header_name ( \"Hello \\r World\" ) False is_legal_header_name ( \"Hello \\t World\" ) False Function normalize_str def normalize_str(string: str) -> str Normalize a string by applying on it lowercase and replacing \u2018-\u2018 to \u2018_\u2019. normalize_str ( \"Content-Type\" ) 'content_type' normalize_str ( \"X-content-type\" ) 'x_content_type' Function prettify_header_name def prettify_header_name(name: str) -> str Take a header name and prettify it. prettify_header_name ( \"x-hEllo-wORLD\" ) 'X-Hello-World' prettify_header_name ( \"server\" ) 'Server' prettify_header_name ( \"contEnt-TYPE\" ) 'Content-Type' prettify_header_name ( \"content_type\" ) 'Content-Type' Function quote def quote(string: str) -> str Surround string by double quote. quote ( \"hello\" ) '\"hello\"' quote ( '\"hello' ) '\"\"hello\"' quote ( '\"hello\"' ) '\"hello\"' Function unfold def unfold(content: str) -> str Some header content may have folded content (LF + 9 spaces, LF + 7 spaces or LF + 1 spaces) in it, making your job at reading them a little more difficult. This function undo the folding in given content. unfold ( \"eqHS2AQD+hfNNlTiLej73CiBUGVQifX4watAaxUkdjGeH578i7n3Wwcdw2nLz+U0bH \\n ehSe/2QytZGWM5CewwNdumT1IVGzjFs+cRgfK0V6JlEIOoV3bRXxnjenWFfWdVNXtw8s\" ) 'eqHS2AQD+hfNNlTiLej73CiBUGVQifX4watAaxUkdjGeH578i7n3Wwcdw2nLz+U0bHehSe/2QytZGWM5CewwNdumT1IVGzjFs+cRgfK0V6JlEIOoV3bRXxnjenWFfWdVNXtw8s' Function unpack_protected_keyword def unpack_protected_keyword(name: str) -> str By choice this project aim to allow developper to access header or attribute in header by using the property notation. Some keyword are protected by the language itself. So : When starting by a number, prepend a underscore to it. When using a protected keyword, append a underscore to it. unpack_protected_keyword ( \"_3to1\" ) '3to1' unpack_protected_keyword ( \"from_\" ) 'from' unpack_protected_keyword ( \"_from\" ) '_from' unpack_protected_keyword ( \"3\" ) '3' unpack_protected_keyword ( \"FroM_\" ) 'FroM_' Function unquote def unquote(string: str) -> str Remove simple quote or double quote around a string if any. unquote ( '\"hello\"' ) 'hello' unquote ( '\"hello' ) '\"hello' unquote ( '\"a\"' ) 'a' unquote ( '\"\"' ) ''","title":"Utils"},{"location":"APIs/others/#kiss_headers.utils","text":"","title":"Module kiss_headers.utils"},{"location":"APIs/others/#functions","text":"","title":"Functions"},{"location":"APIs/others/#kiss_headers.utils.class_to_header_name","text":"def class_to_header_name(type_: Type) -> str Take a type and infer its header name. from kiss_headers.builder import ContentType , XContentTypeOptions , BasicAuthorization class_to_header_name ( ContentType ) 'Content-Type' class_to_header_name ( XContentTypeOptions ) 'X-Content-Type-Options' class_to_header_name ( BasicAuthorization ) 'Authorization'","title":"Function class_to_header_name"},{"location":"APIs/others/#kiss_headers.utils.count_leftover_space","text":"def count_leftover_space(content: str) -> int Recursive function that count trailing white space at the end of given string. count_leftover_space ( \"hello \" ) 3 count_leftover_space ( \"byebye \" ) 1 count_leftover_space ( \" hello \" ) 1 count_leftover_space ( \" hello \" ) 4","title":"Function count_leftover_space"},{"location":"APIs/others/#kiss_headers.utils.decode_partials","text":"def decode_partials(items: Iterable[Tuple[str, Any]]) -> List[Tuple[str, str]] This function takes a list of tuple, representing headers by key, value. Where value is bytes or string containing (RFC 2047 encoded) partials fragments like the following : decode_partials ([( \"Subject\" , \"=?iso-8859-1?q?p=F6stal?=\" )]) [( 'Subject' , 'p\u00f6stal' )]","title":"Function decode_partials"},{"location":"APIs/others/#kiss_headers.utils.extract_class_name","text":"def extract_class_name(type_: Type) -> Union[str, NoneType] Typically extract a class name from a Type.","title":"Function extract_class_name"},{"location":"APIs/others/#kiss_headers.utils.extract_comments","text":"def extract_comments(content: str) -> List[str] Extract parts of content that are considered as comments. Between parenthesis. extract_comments ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 (hello) llll (abc)\" ) [ 'Macintosh; Intel Mac OS X 10.9; rv:50.0' , 'hello' , 'abc' ]","title":"Function extract_comments"},{"location":"APIs/others/#kiss_headers.utils.extract_encoded_headers","text":"def extract_encoded_headers(payload: bytes) -> Tuple[str, bytes] This function purpose is to extract lines that can be decoded using utf-8. extract_encoded_headers ( \"Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n\\r\\n \" . encode ( \"utf-8\" )) ( 'Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n ' , b '' ) extract_encoded_headers ( \"Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n\\r\\n That IS totally random.\" . encode ( \"utf-8\" )) ( 'Host: developer.mozilla.org \\r\\n X-Hello-World: \u6b7b\u306e\u6f22\u5b57 \\r\\n ' , b 'That IS totally random.' )","title":"Function extract_encoded_headers"},{"location":"APIs/others/#kiss_headers.utils.header_content_split","text":"def header_content_split(string: str, delimiter: str) -> List[str] Take a string and split it according to the passed delimiter. It will ignore delimiter if inside between double quote, inside a value or in parenthesis. The input string is considered perfectly formed. This function do not split coma on a day when attached, see \u201cRFC 7231, section 7.1.1.2: Date\u201d. header_content_split ( \"Wed, 15-Apr-2020 21:27:31 GMT, Fri, 01-Jan-2038 00:00:00 GMT\" , \",\" ) [ 'Wed, 15-Apr-2020 21:27:31 GMT' , 'Fri, 01-Jan-2038 00:00:00 GMT' ] header_content_split ( 'quic=\":443\"; ma=2592000; v=\"46,43\", h3-Q050=\":443\"; ma=2592000, h3-Q049=\":443\"; ma=2592000' , \",\" ) [ 'quic=\":443\"; ma=2592000; v=\"46,43\"' , 'h3-Q050=\":443\"; ma=2592000' , 'h3-Q049=\":443\"; ma=2592000' ] header_content_split ( \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\" , \";\" ) [ 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0' ] header_content_split ( \"text/html; charset=UTF-8\" , \";\" ) [ 'text/html' , 'charset=UTF-8' ]","title":"Function header_content_split"},{"location":"APIs/others/#kiss_headers.utils.header_name_to_class","text":"def header_name_to_class(name: str, root_type: Type) -> Type The opposite of class_to_header_name function. Will raise TypeError if no corresponding entry is found. Do it recursively from the root type. from kiss_headers.builder import CustomHeader , ContentType , XContentTypeOptions , LastModified , Date header_name_to_class ( \"Content-Type\" , CustomHeader ) < class ' kiss_headers . builder . ContentType '> header_name_to_class ( \"Last-Modified\" , CustomHeader ) < class ' kiss_headers . builder . LastModified '>","title":"Function header_name_to_class"},{"location":"APIs/others/#kiss_headers.utils.header_strip","text":"def header_strip(content: str, elem: str) -> str Remove a member for a given header content and take care of the unneeded leftover semi-colon. header_strip ( \"text/html; charset=UTF-8; format=flowed\" , \"charset=UTF-8\" ) 'text/html; format=flowed' header_strip ( \"text/html; charset=UTF-8; format=flowed\" , \"charset=UTF-8\" ) 'text/html; format=flowed'","title":"Function header_strip"},{"location":"APIs/others/#kiss_headers.utils.is_legal_header_name","text":"def is_legal_header_name(name: str) -> bool Verify if a provided header name is valid. is_legal_header_name ( \":hello\" ) False is_legal_header_name ( \"hello\" ) True is_legal_header_name ( \"Content-Type\" ) True is_legal_header_name ( \"Hello;\" ) False is_legal_header_name ( \"Hello \\r World\" ) False is_legal_header_name ( \"Hello \\t World\" ) False","title":"Function is_legal_header_name"},{"location":"APIs/others/#kiss_headers.utils.normalize_str","text":"def normalize_str(string: str) -> str Normalize a string by applying on it lowercase and replacing \u2018-\u2018 to \u2018_\u2019. normalize_str ( \"Content-Type\" ) 'content_type' normalize_str ( \"X-content-type\" ) 'x_content_type'","title":"Function normalize_str"},{"location":"APIs/others/#kiss_headers.utils.prettify_header_name","text":"def prettify_header_name(name: str) -> str Take a header name and prettify it. prettify_header_name ( \"x-hEllo-wORLD\" ) 'X-Hello-World' prettify_header_name ( \"server\" ) 'Server' prettify_header_name ( \"contEnt-TYPE\" ) 'Content-Type' prettify_header_name ( \"content_type\" ) 'Content-Type'","title":"Function prettify_header_name"},{"location":"APIs/others/#kiss_headers.utils.quote","text":"def quote(string: str) -> str Surround string by double quote. quote ( \"hello\" ) '\"hello\"' quote ( '\"hello' ) '\"\"hello\"' quote ( '\"hello\"' ) '\"hello\"'","title":"Function quote"},{"location":"APIs/others/#kiss_headers.utils.unfold","text":"def unfold(content: str) -> str Some header content may have folded content (LF + 9 spaces, LF + 7 spaces or LF + 1 spaces) in it, making your job at reading them a little more difficult. This function undo the folding in given content. unfold ( \"eqHS2AQD+hfNNlTiLej73CiBUGVQifX4watAaxUkdjGeH578i7n3Wwcdw2nLz+U0bH \\n ehSe/2QytZGWM5CewwNdumT1IVGzjFs+cRgfK0V6JlEIOoV3bRXxnjenWFfWdVNXtw8s\" ) 'eqHS2AQD+hfNNlTiLej73CiBUGVQifX4watAaxUkdjGeH578i7n3Wwcdw2nLz+U0bHehSe/2QytZGWM5CewwNdumT1IVGzjFs+cRgfK0V6JlEIOoV3bRXxnjenWFfWdVNXtw8s'","title":"Function unfold"},{"location":"APIs/others/#kiss_headers.utils.unpack_protected_keyword","text":"def unpack_protected_keyword(name: str) -> str By choice this project aim to allow developper to access header or attribute in header by using the property notation. Some keyword are protected by the language itself. So : When starting by a number, prepend a underscore to it. When using a protected keyword, append a underscore to it. unpack_protected_keyword ( \"_3to1\" ) '3to1' unpack_protected_keyword ( \"from_\" ) 'from' unpack_protected_keyword ( \"_from\" ) '_from' unpack_protected_keyword ( \"3\" ) '3' unpack_protected_keyword ( \"FroM_\" ) 'FroM_'","title":"Function unpack_protected_keyword"},{"location":"APIs/others/#kiss_headers.utils.unquote","text":"def unquote(string: str) -> str Remove simple quote or double quote around a string if any. unquote ( '\"hello\"' ) 'hello' unquote ( '\"hello' ) '\"hello' unquote ( '\"a\"' ) 'a' unquote ( '\"\"' ) ''","title":"Function unquote"}]}